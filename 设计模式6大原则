### 设计模式6大原则  

##### 单一职责原则    

定义：不要存在多个导致一个类变更的原因。通俗的说，即一个类只负责一项职责。  

问题由来：类T负责两个不同的职责：职责P1，职责P2。由于当职责P1的需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。  

解决方案：遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理当修改T2时，也不会使职责P1发生故障风险。
  
优点： 
  
* 可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多。  
* 提高类的可读性，提高系统的可维护性。  
* 变更引起的风险降低，变更是必然的，如果单一职责遵守的好，当修改一个功能时，可以显著的降低对其它功能的影响。  


##### 里氏替换原则    

这原则是麻省理工学院的一位姓里的女生提出来的。
定义1：如果对每一个类型为T1的对象o1，都有类型T2的对象o2，使得T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。  
定义2：所有引用基类的地方必须能透明地使用其子类对象   

问题由来：有一功能P1，有类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有的功能P1发生故障。   

解决方案：当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。  
继承包含这么一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的契约和规范，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些非抽象方法任意修改，就会对继承体系造成破坏。而里氏替换就表达了这一层的含义。  

里氏替换原则通俗上来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下四层含义：  
  
 * 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。  
 * 子类可以添加自己特有的方法。  
 * 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法输入参数更宽松。
 * 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）比父类更严格。  
  
   
##### 依赖倒置原则    

定义：高层模块不应该依赖底层模块，二者都应该依赖抽象；抽象不应该依赖细节；细节应该依赖抽象。  

问题由来：类A直接依赖类B，假如将类A改为依赖C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责负责的业务逻辑；类B和类C是底层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。  

解决方案：将类A修改为依赖接口I，类B和类C各自实现自己的接口，类A通过接口I间接与类B或者C发生联系，则会大大降低修改类A的几率。   

依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。  

在实际编程中，我们一般需要做到如下3点：

* 低层模块尽量都要有抽象类或接口，或者两者都有。
* 变量的声明类型尽量是抽象类或接口。
* 使用继承时遵循里氏替换原则。  

依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。


##### 接口隔离原则   

定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。  
问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。  

解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。  

采用接口隔离原则对接口进行约束时，要注意以下几点：      

* 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计的灵活性是不争的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。  
* 为依赖接口的类提供定制服务，只暴露给调用的类它需要的方法它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。  
* 提高内聚，减少对外交互。使接口用最少的方法完成最多的事情。  

运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。  

##### 迪米特法则     

定义：一个对象应该对其他对象保持最小的了解  
问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。  
  
解决方案：尽量降低类与类之间的耦合。  

自从我们接触编程开始，就知道了软件编程的总的原则：低内聚，高耦合。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合？那正是迪米特法则要去完成的。  
迪米特法则又叫最少知道原则，最早是在1987年由美国Northeastern University的Ian Holland提出。通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。迪米特法则还有一个更简单的定义：只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。  

##### 开闭原则   

定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。

问题来源：在软件的声明周期内，因为变化、升级和维护等原因对原有代码进行修改时，可能会给旧代码引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码进行重新测试。  

解决方案：当软件需求变化时，尽量通过扩展软件实体的行为实现变化，而不是通过修改已有的代码来实现变化。  

开闭原则可以应用到各个原则中去，用抽象构建框架，用实现扩展细节都是开闭原则的体现。   




