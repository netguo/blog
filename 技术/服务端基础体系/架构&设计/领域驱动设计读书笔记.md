# 第一部分让领域模型发挥作用
## 第一章消化知识
模型是一种简化。它是对实现的解释，并把解决问题密切相关的方面抽象出来，而忽略无关的细节。 
### 1.1 有效建模
模型和实现绑定、获得了一种基于模型的语言、开发一个蕴含丰富知识的模型、提炼模型、头脑风暴和实验
### 1.2 消化知识
在大量的信息中探寻有用的部分，不断尝试各种信息组织方式，努力寻找对大量信息有意义的简单视图。
在团队所有成员一起消化理解业务模型过程中，领域模型的不断精化迫使开发人员学习重要的业务原理，而不是机械地进行功能开发。
### 1.3 持续学习
所有项目都会丢失只是，高效的团队需要有意识的积累知识，并持续学习。
### 1.4 知识丰富的设计
模型发生改变的同时，开发人员对实现进行重构，以便反映出模型的变化
当我们不再局限寻找实体和值对象时，我们才能充分吸收知识
正是通过消化知识的过程才能使得业务规则得以澄清和充实
### 1.5 深层模型
随着对领域和应用程序需求的理解逐步加深，往往会丢掉那些最初看起来很重要的表面元素，一些在开始不可能发现的巧妙抽象就会渐渐浮出水面，而它们恰恰切中问题要害。
知识消化是一种探索，它永无止境。

## 第二章语言的交流和使用
### 2.1 ubiquitous language
将模型作为语言中心，确保团队在所有交流活动和代码中坚持使用这种语言。
### 2.2 “大声地”建模
讨论系统时要结合模型。使用模型的元素以及模型中的各种元素之间的交互来大声描述场景，并且按照模型允许的方式将各种概念结合到一起。找到更简单的表达方式来讲出你要讲的话，然后将这些新的思想应用到图和代码中。
### 2.3 一个团队，一种语言
开发语言，建模语言，应该保持词汇一致，使用同一种语言
### 2.4 文档和图
图可以采用非正式的UML图，促成头脑风暴，UML正式图过于细节，设计重要的细节在代码中体现出来。模型不是图，图的目的是帮助表达和解释模型。
文档作为代码和口头交流的补充，文档不应再重复表示代码已经明确表达出的内容。
文档应努力寻求生存之道并保持最新，文档必须深入到项目个各个活动中去。
完全依赖可执行代码的情况，代码名称应该消除歧义，所传达的消息与它的行为和意图保持一致。
### 2.5 解释性模型
解释性模型不必是对象模型，而且最好不是，可以专门为某特殊主题定制的表达力更强的表示，便于更好的解释。

## 第三章 绑定模型和实现
### 3.1 MODEL- DRIVEN DESIGN 模型驱动设计
严格按照基础模型来编写代码，能够使代码更好的表达设计含义，并且使模型更符合设计。
如果整个程序设计或者其核心部分没有领域模型相对应，那么这个模型就是没有价值的，软件的正确性也值得怀疑。
建模和程序设计结合为一个统一的迭代开发过程，各部分设计应该如实反映领域模型，反复检查并修改模型，在软件中更加自然的实现模型。
### 3.2 建模范式和工具支持
完全依赖模型的实现通车需要支持建模范式的软件开发工具和语言，比如面向对象编程。
### 3.3 为什么模型对用户至关重要
让用户更了解模型，给他们更多的机会挖掘软件潜能，使软件行为合乎情理、前后一致。
### 3.4 HANDS- ON MODELER
任何参与建模的技术人员，不管在项目中的主要职责是什么，都必须花时间了解代码，任何负责修改代码的人员必须学会用代码来表达模型。将建模和编程过程完全分离是行不通的。

---

# 第二部分 模型驱动设计的构造块
## 第四章 分离领域
### 4.1 layered architecture
尽管layered architecture种类繁多，但是大多数成功的架构使用的都是包括这四个概念层：用户界面层（或表示层）、应用层、领域层、基础设施层。
给复杂的应用划分层次。在每一层内分别进行设计，使其具有内聚性并且只依赖于它下层。领域对象应该将重点放在如何表达领域模型上，而不需要考虑自己的显示和存储问题。
### 4.2 模型属于领域层
将领域实现独立出来是领域驱动设计的前提
### 4.3 模式：智能用户界面
一个经验并不丰富的项目团队要完成一个简单的项目，使用模型驱动设计，会是一个艰难的过程，时间花费较长。在用户界面中实现所有的业务逻辑，采用关系型数据库作为共享数据存储库，在某些场景下，它能发挥最佳作用。
### 4.4 其它分离模式
一些其它模式例如：bounded context和anticorruption layer，在后续章节中会进行讨论。

## 第五章 软件中所表示的模型
### 5.1 关联
在早起进行头脑风暴活动并探索领域时，会得到比较多的关联，至少有三种方法可以使关联更容易控制：规定一个遍历方向；添加一个限定符，以便减少多重关联；消除不必要的关联；
### 5.2 模式：ENTITY
一些对象主要不是由它们的属性定义的，它们实际上是一条标识线，这条线经过一个时间跨度，对象在这条线是通过经历了多种不同的表示。
当一个对象由其标识（而不是属性）区分时，那么在模型中应该主要通过标识来确定该对象的定义。模型必须定义出“符合什么条件才算相同的事物”。
并不是每一个事物都必须有一个标识，标识重不重要，完全取决于它是否有用。
#### 5.2.1 ENTITY建模
ENTITY的最基本职责是确保连续性，以便使其行为更清楚且可预测。保持实体的简练是实现这一职责的关键，抓住对象定义的最基本特征，对概念至关重要的行为和这些行为所必需的属性，将其他行为转移到与核心实体关联的其他对象中。
#### 5.2.2 设计标识操作
每一个ENTITY都必须有一种建立标识的操作方式，不管系统如何定义，都必须确保标识属性在系统中是唯一的。有时候某些数据属性或属性组合可以确保它们在系统中具有唯一性。如果对象属性没有唯一键，常常为每一个实例附加一个唯一性ID。
### 5.3 模式：VALUE OBJECT
当我们只关心一个模型元素的属性时，应把它归类为VALUE OBJECT。这个模型的元素能够表示属性的意义，并为它提供相关功能。VALUE OBJECT应该是不可变的，不要为它分配任何标识。
这些对象是用来描述事物的对象，如果加上唯一性标识会增加模型复杂性。
VALUE OBJECT可以是其它对象的集合，也可以引用ENTITY，经常作为参数在对象之间传递，常常是临时对象。
#### 5.3.1 设计VALUE OBJECT
复制和共享哪个更划算取决于实现环境，复制导致系统被大量的对象阻塞，共享可能会减慢分布式系统的速度。
只要value object是不可变的，变更管理就会很简单。可以极大简化实现，并确保共享和引用的安全传递。
如果一个value的实现是可变的，那么就不能共享它，在可能的情况下都将它们设计为不可变的。
通过VALUE OBJECT来优化数据库：如果被数据库中不同ENTITY引用，VALUE OBJECT跟ENTITY存在不同的页中。优化性能，可能在不同ENTITY中存储。
#### 5.3.2 设计包含VALUE OBJECT的关联
尽量完全清除VALUE OBJECT之间的双向关联
### 5.4 模式：SERVICE
一些领域概念不适合被建模城对象，如果勉强归位ENTITY或VALUE OBJECT的职责，会歪曲了模型对象的定义或者人为增加一些无意义的对象。
当领域中的某个重要的过程或转换操作不属于实体或值对象的自然职责时，应该在模型中添加一个作为独立接口的操作，并将其声明为SERVICE。
SERVICE定义为无状态的，任何客户使用SERVICE的任何实例，不必关心该实力的历史状态。
#### 5.4.1 SERVICE与孤立的领域层
应用层SERVICE和领域层SERVICE可能很难区分，领域层SERVICE涉及到基本的业务逻辑，技术层SERVICE应该没有任何业务意义。
#### 5.4.2 粒度
大型系统中，中等粒度、无状态的SERVICE更容易被重用。
#### 5.4.3 对SERVICE的访问
提供对SERVICE的访问机制意义并不是十分重大，我们很容易编写一个简单的单例来实现。在一下分布式框架中，提供职责分离的决策架构，提供SERVICE的发布机制。
### 5.5 模式：MODULE（PACKAGE）
MODULE之间应该是低耦合的，内部则是高内聚的。MODULE不仅仅是代码的划分，也是概念的划分。
 MODULE可以将那些具有紧密概念关系的模型元素集中到一起，将这些具有相关职责的对象元素聚合到一起，会极大降低建模和设计的复杂性。
#### 5.5.1 敏捷的MODULE
MODULE需要与模型的其他部分一同演变，意味着MODULE的重构必须与模型和代码一起进行。
#### 5.5.2 基础设施驱动的打包存在着隐患
分层架构可能导致模型对象实现的分裂。一些框架的分层方法是把一个领域对象的职责分散到多个对象中，然后把这些对象放在不同的包中。最好的做法是使用比ENTITY对象具有更大粒度的EJB，从而减少分层的副作用。
### 5.6 建模范式
#### 5.6.1 对象范式流行的原因
对象建模在简单性和复杂性之间实现了一个很好的平衡。大部分比较容易自己面向对象设计的基本知识，尽管非专业人士也可以理解对象模型图。
开发者社区和设计文化的成熟也同样重要，采用新范式的项目可能很难找到精通它的开发人员。
#### 5.6.2 对象世界中的非对象
领域模型不一定是对象模型，例如有的模型是由逻辑规则和事实构成的。当领域中只有极少数个别元素适合其他范式时，开发人员可以勉强接受都用模型范式来处理他们。但是，当领域的主要部分属于不同范式时，适合各个部分的范式对每个部分分别建模，并使用混合工具集为实现提供支持。
业务规则引擎或工作流引擎就是这样非对象组建集成到对象系统中，混合使用不同范式使得开发人员能够使用最适用的风格对特殊概念进行建模。
#### 5.6.3 在混合范式中坚持使用MODEL- DRIVEN DESIGN
规则引擎就是一个常见的例子，一个包含丰富知识的领域模型可能会含有一些显示的规则，然而对象范式却缺少用于表达规则和规则交互的具体语义。
将非对象元素混合到面向对象为主的系统中时，需要遵循以下4条经验规则：
不要和实现范式对抗。找到适合于范式的模型概念。
把通用语言作为依靠的基础。即使工具之间没有严格的联系，语言上使用上的高度一致性也能防止各个设计部分的分裂。
不要一味依赖UML。有时使用其他绘图风格或者简单语言描述比牵强附会地适应某种绘图风格更好。
保持怀疑态度。

## 第六章 领域对象的生命周期
### 6.1 模式：AGGREGATE
将ENTITY和VALUE OBJECT分门别类放到AGGREGATE中，并定义每个AGGREGATE的边界。在每个AGGREGATE中，选择一个ENTITY作为根，并通过根来控制对边界内其他对象的所有访问。只允许外部对象保持对根的引用。对内部成员的临时引用可以被传递出去，但仅在一次操作中有效。由于根控制访问，因此不能饶过它来修改内部对象。这种设计有利于确保AGGREGATE中的对象满足所有固定规则，也可以确保在任何状态变化时AGGREGATE作为一个整体满足固定规则。
### 6.2 模式：FACTORY
对象的创建本身可以是一个主要操作，但被创建的对象并不适合承担复杂的装配操作。将这些职责混合在一起可能导致出现难以理解的拙劣设计。让客户直接负责创建对象，会导致客户与被创建对象之间产生过于紧密的耦合。
每种面向对象语言都提供了一种创建对象的机制，但我们仍然需要一种更加抽象且不与其他对象发生耦合的构造机制。这就是FACTORY，它是一种负责创建其他对象的程序元素。
应该将创建复杂对象的实例和聚合的职责转移给一个单独的对象，这个对象本身在领域中可能没有指责，但它仍是领域设计的一部分。
FACTORY有很多种设计模式，工厂方法、抽象工厂、构造器
#### 6.2.1 选择FACTORY及其应用位置
可以在AGGREGATE根上创建一个FACTORY方法，整个AGGREGATE通常由一个独立的FACTORY来创建。
#### 6.2.2 有些情况下只需要使用构造函数

- 类是一种类型。它不是任何相关层次结构的一部分，也没有通过接口实现多态。
- 客户关心的是实现
- 客户可以访问对象的所有属性
- 构造并不复杂
- 公共构造函数必须是一个原子操作，且满足被创建对象的所有固定规则
#### 6.2.3 接口设计
无论独立的FACTORY，还是FACTORY METHOD都需要满足：每个操作都必须是原子的，FACTORY将与其参数发生耦合。
#### 6.2.4 固定规则的逻辑应放置在哪里
可以见固定规则检查工作委派给产品，也可以在FACTORY中放置。具体看看规则自身行为在哪里更合适。
#### 6.2.5 ENTITY FACTORY 与 VALUE  OBJECT FACTORY
VALUE  OBJECT是不可变的，FACTORY操作必须提供产品的完整描述。
ENTITY只需要构造有效AGGREGATE所需要的那些属性，涉及到标识分配时，可以外部传入，如果需要创建，FACTORY创建更为合适。
#### 6.2.6 重建已存储的对象
用于重建对象的ENTITY FACTORY不必分配新的跟踪ID。
当规定规则没有被满足时，重建对象的FACTORY需要更灵活的响应，而不是简单的拒绝。
### 6.3 模式：REPOSITORY
从技术观点来看，检索一个已存储对象过程实际上属于一种创建对象的操作，从已存储的数据中创建实例的过程称为重建。
为每种全局访问的对象类型创建一个对象，这个对象就相当于该类型的所有对象在内存中的一个集合的“替身”。通过一个接口来提供访问，提供添加和删除对象的方法，用这些方法来封装在暑假存储中实际插入或删除数据操作。提供根据具体标准来查询对象的方法，从而将实际存储和查询技术封装起来。所有对象存储和访问操作交给REPOSITORY来完成。
#### 6.3.1 REPOSITORY查询
可以构建一个支持灵活查询的REPOSITORY框架，客户可以使用规格来描述它需要什么，而不必关系如何获得结果。
#### 6.3.2 客户代码可以忽略REPOSITORY的实现，但开发人员不能忽略
开发人员需要理解使用封装行为的隐含问题，但并不意味着要熟悉实现的每个细节。
#### 6.3.3 REPOSITORY的实现
理想的实现是向客户隐藏所有内部工作细节，这样不管数据是存储在对象数据库中，还是存储在关系数据库中，或是简单地保持在内存中，客户代码都是相同。
实现注意事项：

- 对类型进行抽象
- 充分利用REPOSITORY与客户解耦得优点
- 将事务控制权留给客户
#### 6.3.4 在框架内工作
在使用基础设施或者中间件框架时，要顺其自然，在大方向上保持领域驱动设计的基本要素，而一些不符的细节不必过分苛求。如果可以自由选择，那么应该选择与你所使用的设计风格相协调的框架或者框架的一部分。
#### 6.3.5 REPOSITORY与FACTORY的关系
FACTORY负责处理对象生命周期的开始，而REPOSITORY帮助管理生命周期的中间和结束。
### 6.4 为关系数据库设计对象
从技术上来看，关系表的设计不必反映出领域模型，映射工具已经非常精巧，足以消除两者之间的巨大差别。

- 当数据库被视作对象存储时，数据模型与对象模型的差别不应太大。
- 对象系统外部的过程不应该访问这样的对象存储。

大多数情况下关系数据库是面向对象领域中的持久化存储形式，因此简单的对应关系才是最好的。
## 第七章 使用语言：一个扩展的示例
本章主要介绍了一个货运系统的示例，不多做笔记
7.1 货物运输系统简介
为了建立一个健壮的实现，模型需要更清晰和严密一些。
7.2 隔离领域：应用程序的引入
应用层是协调者，它们只负责提问，而不负责回答，回答是领域层的工作。
7.3 将ENTITY和VALUE OBJECT区分开
依次考虑每个对象，看看这个对象是必须被跟踪的实体还是仅表示一个基本值。
7.4 设计运输系统中的关联
理解遍历方向能够使模型更深入
7.5 AGGREGATE边界
7.6 选择REPOSITORY
7.7 场景走查
经常走查场景，以确保能够有效地解决应用问题
7.7.1 应用程序特性举例
7.7.2 应用程序特性举例：重复业务
7.8 对象的创建
7.8.1 FACTORY和构造函数
7.8.2 添加一个Handling Event
7.9 停下来重构：AGGREGATE的另一种设计
7.10 运输模型中的MODULE
7.11 引入新特性：配额检查
7.11.1 连接两个系统
7.11.2 进一步完善模型：划分业务
7.11.3 性能优化
7.12 小结

---

# 第三部分 通过重构来加深理解
要想成功地开发出实用的模型，需要注意以下3点：

- 复杂巧妙的领域模型是可以实现的，也是值得我们花费力气实现的。
- 这样的模型离开不断的重构是很难开发出来的，重构需要领域专家和热爱学习领域知识的开发人员密切参与进来。
- 要实现并有效地运用模型，需要精通设计技巧

重构的层次
几乎所有重构的文献，都是修改代码使其更具可读性或者在非常细节的层次上有所改进，或者利用设计模式进行重构。这些都是技术的角度。
有些重构能够极大地提高系统的可用性，它们源于对领域的新认知，有的能够通过代码清晰的表达出模型的含义。
深层模型
深层模型能够穿过领域表象，清楚地表达出领域专家们的主要关注点以及最相关的知识。以及定义并没有提及的抽象问题。
深层模型/柔性设计
不断的重构能给系统最需要修改的地方增添灵活性，也能简单快捷的方式来实现普通功能。反复尝试，不断改正错误，对模型和设计改进更容易实现。
发现过程
需要富有创造力，不断地尝试，不断地发现问题才能找到合适的方法为你发现的领域概念建模，但有时你也可以借用别人已建好的模式。
有时，当我们拥有了MODEL- DRIVEN DESIGN和显式概念，就能产生突破，有机会使软件更富表达力、更加多样化，甚至超乎我们想象。
## 第八章 突破
重构的投入与回报并非呈线性关系，小的调整会带来小的回报，小的改进也会积少成多。有些最重要的理解也会突然出现，给这个项目带来巨大的冲击。
一般来说，持续重构是为了突破做好准备。每次重构都让开发人员又了更加清晰的认识，这使得有了突破的可能性。
### 8.1 一个突破的故事
经过一个冬天的漫长重构之后，最终得到了能够捕捉到一些领域关键知识的模型和一个确实能在应用程序中发挥作用的设计。
### 8.2 机遇
当突破带来更深层的模型时，通常会令人感到不安。与大部分重构相比，这种变化的回报更多，风险也跟高。而且突破出现的时机可能很不合时宜。
在很多项目中，建模和设计工作最重要的进展都来自于突破。
### 8.3 关注根本
不要试图去制造突破，那只会使项目陷入困境。通常，只有在实现了许多适度的重构后才有可能出现突破。
要为突破做好准备，应专注于知识消化过程，同时也要逐渐建立健壮的UBIQUITOUS LANGUAGE。
不要犹豫着不去做小的改进，这些改进近视脱离不开常规的概念框架，也可以逐渐加深我们对模型的理解。
### 8.4 后记：越来越多的新理解
通常，在经过一次真正的突破并获得了深层模型之后，所获得的新设计变得更加清晰简单，新的UBIQUITOUS LANGUAGE 也会增进沟通，于是又促成了下一次建模突破。
## 第九章 讲隐私概念转变为显示概念
深层建模的第一步就是要设法在模型中表达出领域的基本概念，随后，在不断消化知识和重构的过程中，实现模型精化。
### 9.1 概念挖掘
#### 9.1.1 倾听语言
倾听领域专家使用的语言。有没有一些术语能够简洁地表达复杂的概念？他们有没有纠结过你的用词？当你使用某个特定短语时，他们脸上还流露出迷惑的表情吗？这些都暗示了某些概念也许可以改进模型。
#### 9.1.2 检查不足之处
要挖掘的地方就是设计中不足的地方，也就是操作复杂难以解释的地方。
#### 9.1.3 思考矛盾之处
不同的领域专家对同样的事情会有不同的看法，这取决于他们的经验和需求。
要解决所有矛盾是不太现实的，甚至是不需要的。即使不去解决矛盾，也应该思考对立的两种看法是如何同时应用于同一个外部现实的。
#### 9.1.4 查阅书籍
查阅书籍也许能够使你一开始就形成一致且深沉的认识。
#### 9.1.5 尝试，再尝试
只有不断尝试才能了解什么有效，什么无效。
### 9.2 为那些不太明显的概念建模
#### 9.2.1 显式的约束
约束是模型概念中非常重要的类别，它们通常是隐式出现的，将它们显式地表现出来可以极大地提高设计质量。
#### 9.2.2 作为领域对象的过程
我们都不希望过程变成模型的主要部分。对象是用来封装过程的，而我们只需要考虑对象的设计目的或意图就可以了。
过程应该被显示的表达出来，还是应该被隐藏起来呢？区分的方法很简单：它是经常被另一专家提前的呢，还是仅仅被当作计算机程序机制的一部分？
#### 9.2.3 模式：SPECIFICATION
业务规则通常不适合作为ENTITY或VALUE OBJECT的职责，而且规则的变化和组合也会掩盖领域对象的基本含义。但是将规则移除领域层的结果会更糟糕，这样一来，领域代码就不再表达模型。
逻辑编程提供了一种概念，即“谓词”（是/否..）这种可分离，可组合的规则对象，但是要把这种概念用对象完全实现是很麻烦的。
SPECIFICATION概念很简单，为谓词创建一个显示的VALUE OBJECT，可以成为规格，用来确定对象是否满足某些标准。
#### 9.2.4 SPECIFICATION的应用和实现
可用于实现以下几个目的：

- 验证对象，检查它是否能满足某些需求或者是否已经为实现某个目标做好了准备。
- 从集合中选择一个对象
- 指定在创建新对象时必须满足某种需求

**验证**
独立的验证基类，可以利用多态实现不同子类
**选择（或查询）**
SPECIFICATION与REPOSITORY搭配，REPOSITORY作为一种构造块机制，提供了对领域对象的查询访问，并且把数据库接口封装起来。
**根据要求来创建（生成）**
创建或者重新装配满足规格的全新对象或者对象集合，可以通过规格来定义生成器接口

- 生成器的实现与接口分离
- 接口把规则显式地表达出来
- 接口更灵活，或者说我们可以增强其灵活性
- 接口更加便于测试
## 第十章 柔性设计
为了使项目能够随着开发工作的进行加速前进，而不会由于它自己的老化停滞不前，设计必须要让人们乐于使用，而且易于做出修改，这就是柔性设计。柔性设计是对深层建模的补充。
很多过度设计借着柔性设计的名义而自认为是正当的。
开发人员扮演着两个角色，而设计必须为这两个角色服务。一个角色是客户开发人员，负责将领域对象组织称应用程序代码或者其它领域代码，以便发挥设计作用。同样重要的是，设计也必须为那些修改代码的开发人员服务。为了便于修改，设计必须易于理解。
### 10.1 模式：intention- revealing interfaces  释意接口
在命名类和操作时，要描述它们的效果和目的，而不要表露它们是通过何种方式达到目的的。这样可以使客户开发人员不必理解内部细节。这些名称应该与UBIQUITOUS LANGUAGE保持一致，以便团队成员可以迅速推断出它们的意义。
如果开发人员为了使用一个组件而必须去研究它的实现，那么就失去了封装的价值。当某个人开发的对象和操作被别人使用时，如果使用这个组建的新的开发者不得不根据其实现来推测其用途，那么他推测出来的可能并不是那个操作或类的主要用途。
### 10.2 模式：side- effect- fres function 无副作用的函数
尽可能把程序的逻辑放到函数中，因为函数是只返回结果而不产生明显副作用的操作。严格地把命令隔离到不返回领域信息的、非常简单的操作中。当发现了一个非常合适承担复杂逻辑职责的概念时，就可以把这个复杂逻辑移到VALUE OBJECT中，这样可以进一步控制副作用。
### 10.3 模式：assertion 断言
把操作的后置条件和类及assertion的固定规则表述清楚。如果在你的编程语言中不能直接编写assertion，那么就把它们编写成自动的单元测试。
### 10.4 模式：conceptual contour 概念轮廓
把设计元素（操作、接口、类和聚合）分解为内聚的单元，在这个过程中，你对领域中一切重要的划分的直观认识也要考虑在内。在连续的重构过程中观察发生变化和保证稳定的规律性，并寻找能够解释这些变化模式的底层概念轮廓。是模型与领域中那些一致的方面相匹配。
### 10.5 模式：standalone class  独立类
低耦合时对象设计的一个基本要素。尽一切可能保持低耦合。把其他所有无关概念提取到对象之外。这样类就变成完全孤立的累，这就使得我们可以单独地研究和理解它。
低耦合时减少概念过载的最基本方法。孤立的类是低耦合的极致。
### 10.6 模式：closure of operation  闭合操作
在适当的情况下，在定义操作时，让它的返回类型与其参数的类型相同。如果实现者的状态在计算中被用到，那么实现者实际上就是操作的一个参数，因此参数和返回值应该与实现者有相同的类型。这样的操作就是在该类型的实例集合中的闭合操作。闭合操作提供了一个高层接口，同时又不会引入其他概念的任何依赖性。
### 10.7 声明式设计
声明式设计，对于不同的人来说具有不同的意义，但通常指一种编程方式，把程序或程序的一部分写出一种可执行的规格。使用声明式设计时，实际上是由一些非常精确的熟悉描述来控制的。可以有多种实现方式：反射，编译时通过代码生成等。
声明式设计的最大价值是用一个范围非常窄的框架来自动处理设计中某个特别单调且易出错的方面，例如持久化和对象关系映射。
**特定于领域的语言**
特定于领域的语言是一种有趣的方法，它有时也是一种声明式语言。采用这种编码风格时，客户代码是一种专门为特殊领域的特殊模型定制的语言而编写的。
### 10.8 声明式设计风格
**用声明式的风格来扩展规格**
specification规格组合，也是可以设计成闭合设计
**使用逻辑运算对specification规格进行组合**
参考书中具体例子
### 10.9 切入问题的角度
#### 10.9.1 分割子领域
我们无法一下子就能处理好整个设计，而需要一步一步的进行。我们从系统的某些方面可以看出合适哪些方法进行处理，那么就把他们提取出来出来，可以提取到一个单独的模型活着简单声明规则的框架。重点突击某个部分，使设计的一个部分真的变得灵活起来，这比分散精力范范地处理整个系统要有用的多。
#### 10.9.2 尽可能利用已有的形式
我们不能把从头创建一个严密的概念框架当作一个日常工作来做，在项目生命周期中，我们有时会发现并提炼出这样一个框架。但更常见的情况是，可以对的领域或其他领域中那些建立已久的概念系统加以修改和利用。
## 第十一章 分析模式的应用
深刻的模型和柔性的设计并不会轻易得到，要想取得进展，必须学习大量领域知识并进行充分的讨论，还需要经历大量的尝试和失败。
《分析模式》马丁福勒的一本书
分析模式是一种概念集合，用来表示业务建模中的常见构造。它可能只与一个领域有关，也可能跨多个领域。分析模式并不是技术解决方案，而只是用来指导人们设计特定领域中的模型。
在一个成熟的项目上，莫醒选择往往是根据实用经验做出的。人们已经尝试各种组件的多种实现方法。其中的一些实现已经被采用，甚至已经到了维护阶段。这些经验可以帮助人们避开很多问题。分析模式最大的作用是借鉴其他项目的经验，把项目中做的广泛的设计方向和实现结果的经验与当前的模型结合起来。
## 第十二章 将设计模式应用于模型
并非所有的设计模式都可以用作领域，设计模式的动机以及模式本身都是纯技术角度描述的。但这些元素中一部分在更广泛的领域和实际上下文中也适用。我们必须从两种角度看待他们：从代码角度来看它们是技术设计模式，从模型的角度来看它们就是概念模式。

## 第十三章 通过重构得到更深层的理解
三件事情是必须要关注的：

- 以领域为本
- 用一种不同的方式看待事物
- 始终坚持与领域专家对话
### 13.1 开始重构
重构可能是为了解决代码中的一个问题。
与传统观点不同的是，即使在代码看上去很整洁的时候也可能需要重构，原因是模型的语言没有与领域专家保持一致。
### 13.2 探索团队
如果重构是寻找新模型，需要比较多时间，需要多人参与工作。发起者应该挑选几位开发来一起工作，这些开发应该擅长思考该类型问题或者掌握深厚的建模技巧。
### 13.3 借鉴先前的经验
有时可以从分析模式中汲取他人的经验。这些经验对于帮助我们读懂领域起到一定的作用。
### 13.4 针对开发人员的设计
软件不仅仅是为用户提供的，也是为开发人员提供的。
### 13.5 重构的时机
持续重构渐渐被认为是一种“最佳实践”。
### 13.6 危机就是机遇
对模式进行精华是一个稳定的过程，在这个过程中，你可能突然有所顿悟。这样的情况不像机遇，更像危机。例如，突然发现模型中有一些明显的缺陷。这些表明团队对模型已经达到一个新的水平。
在达尔文创建进化论后的一个多世纪中，人们一直认为标准的进化模型就是物种随着时间而缓慢改变。突然之间，这个模型在20世纪70年代被“间断平衡”模型所取代。它对原有进化论进行了扩展，认为长期的缓慢变化或稳定性变化会被相对来说很短、爆发性的快速变化所打断。然后事物进入一个新的平衡。

---

# 第四部分 战略设计
战略设计原则，必须指导设计策略，以便减少各部分之间的相互依赖，并提高清晰度，而又不丢失关键的互操作性和协同性。战略设计原则必须把模型的重点放在捕获系统的概念核心，也就是系统的“远景”上。而且在完成这些目标的同时又不能为项目带来麻烦。
## 第14章  保持模型的完整性
大型系统领域模型的完全统一是不可行的，也不是一种经济有效的做法。
除了技术上因素，权力上的划分和管理级别的不同也要求把模型分开。而且不同的模型的出现也可能是团队组织和开发过程导致的结果。
在整个企业中为何统一模型并不可行，预先决定什么应该统一，并实际认识到什么不能统一，我们就能创建一个清晰的、共同的视图。我们需要用一种方式来标记出不同模型之间的边界和关系。
### 14.1 模式：bounded context
任何一个大型项目都会存在多个模型。而当基于不同模型的代码被组合到一起后，软件就会出现bug，变得不可靠和难以理解。团队成员之间的沟通变得混乱。人们往往弄不清楚一个模型不应该在哪个上下文中使用。
明确地定义模型所应用的上下文。根据团队组织、软件系统的各个部门的用法以及物理表现（代码和数据库模式等）来设置模型边界。在这些边界中严格保持模型的一致性，而不要受到边界之外问题的干扰和混淆。
**识别bounded context中的不一致**
将不同模型的元素组合到一起可能会引发两类问题：重复概念和假同源。
重复的概念是指两个模型元素（以及伴随的实现）实际上表示同一个概念。每当这个概念发生变化时，都必须修改两个地方。
假同源，它是指相同的术语，开发者认为是在表示同一个概念，但实际上并不是这样。
### 14.2 模式：continuous integration
持续性整合
当很多人在同一个上下文工作时，模型很容易发生分裂，如果将系统分解为更小的context，最终难以保持集成度和一致性。
建立一个经常把所有代码和其他实现工件合并到一起的过程，坚持使用统一语言，所有人对模型都能达成一个共识。
### 14.3 模式：context map
定义不同上下文之间的关系，并在项目中创建一个所有模型上下问的全局试图。
为每个bounded context命名，并把名称添加到ubiquitous language中。
#### 14.3.1 测试context的边界
#### 14.3.2 context map的组织和文档化

- bounded context应该有名称
- 每个人都应该知道边界在哪里
### 14.4 bounded context之间的关系
如果团队需要为不同的用户群提供服务，可能就需要采用shared kernel（共享内核）或customer/supplier（客户/供应商）关系。系统集成并不重要，系统最好采用separate way（独立自主）模式。大多数项目都需要与遗留系统或外部系统进行一定程度的集成，这就需要使用open host service（开放主机服务）或 anticorruption layer（防护层）。
### 14.5 模式：共享内核（shared kernel）
领域模型中两个团队共享一个子集，包括代码子集，或数据库设计子集。明确共享的内容具有特殊状态，而且一个团队在没与另外一个团队商量的情况下不应该擅自更改它。
共享内核通常是core domain，或是一组通用子领域。
### 14.6 模式：客户/供应商（customer/supplier development team）
上游团队依赖下游团队，上游团队却不负责下游团队产品。在两个团队之间建立一种明确的客户/供应商关系。下游团队相当于上游团队的客户，根据下游团队的需求来协商需要执行的任务，并未这些任务做预算。两个团队一起开发自动验收测试，用验证预期接口 。
注意此处，上游下游与依赖方向相反，是提供服务方向，底层是上游。从供应链角度，供应商是上游，客户是下游。
### 14.7  模式：跟随者（conformist）
当两个开发团队具有上/下游关系时，如果上游团队没有动机来满足下游团队的需求，那么下游团队将无能为力。通过严格遵循上游团队的模型，可以消除bounded context之间进行转换的复杂性。尽管限制了下游团队设计风格，但是可以极大地简化集成。供应商处于驾驶者的位置上。
### 14.8 模式：防腐层（anticorruption layer）
当正在构建的新系统与另一个系统接口差异和大时，为了克服连接两个模型而带来的困难。
创建一个隔离的层，以便客户根据自己的领域模型来为客户提供相关的功能，这个层通过现有的接口与另一个系统进行对话，另外系统只需要作出很少的修改，甚至无修改。在内部，这个层在两个模型之间进行必要的双向转换。
#### 14.8.1 设计防腐层接口
防腐剂的公共接口通常以一组service形式出现，偶尔也会采用entity。
#### 14.8.2 实现防腐层
对防腐层设计进行组织的一种方法是把它实现为facade、adapter（这两种设计模式）和转换器的组合，外加两个系统之间进行对话所需的通信和传输机制。
facade是子系统的一个可供替换的接口，它简化对客户的访问，并使子系统更容易使用。
adapter是一个包装器，它允许客户使用另外一种协议，这种协议可以是行为实现者不理解的协议。
adapter的工作是知道如何生成请求，概念对象或数据的实际转换是一种完全不同的复杂任务，我们可以让一个单独的对象来承担这项任务。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/8364057/1656492700781-7619ad91-0f97-4eaa-b42a-97d3b4a2a9d7.png#averageHue=%23f0f0f0&clientId=udc95d790-3c00-4&from=paste&height=163&id=ue30b6ecd&originHeight=766&originWidth=2420&originalType=binary&ratio=1&rotation=0&showTitle=false&size=193833&status=done&style=none&taskId=u437cdb6a-7ecd-4981-ac62-320ae492938&title=&width=516)
### 14.9 模式：独立自主（separate way）
声明一个与其他上下文毫无关联的bounded context，使开发人员能够在这个小范围内找到简单、专用的解决方案。
### 14.10 模式：开放主机服务（open host service）
定义一个协议，把子系统作为一组service供其他系统服务。
### 14.11 模式：公共语言（published language）
把一个良好文档化的、能够表达出所需领域信息的共享语言作为公共的通信媒介，必要时在其他信息与该语言之间进行转换。
例如：CML（化学标记语言）是化学领域的公共交流语言被开发出来的专用XML。由一个代表学术界和化学界的组织负责开发和管理。
### 14.12 “大象”统一
承认多个模型相互冲突实际上正是面对现实的做法，通过定义每个模型都适用的上下文，可以维护每个模型的完整性。盲人没法看到整个大象，但只要他们承认各自理解是不完整的，他们的问题就能得到解决。
### 14.13 选择你的模型上下文策略
#### 14.13.1 制定团队决策或更高层的决策
首先，团队必须决定在哪里定义bounded context，以及它们之间有什么样的关系，并被团队里每个人理解。
#### 14.13.2 在上下文中工作
在开发软件项目时，我们首先是对自己的团队正在开发的那些部分感兴趣，其次是对那些与我们交互的系统感兴趣。
#### 14.13.3 转化边界
在画bounded context的边界时，有无数情况，也有无数种选择，通常对下面因素进行权衡。
**首先较大的bounded context**
任务之间的流动更顺畅、内部映射更容易理解、两个模型之间的转换可能会很难、共享语言团队沟通更清楚。
**首选较小的bounded context**
开发人员之间的沟通开销更小、持续性整合更容易、较大的上下文需要更加通用的抽象，而掌握所需技巧的人员会出现短缺、不同的模型可以满足一些特殊的需求
#### 14.13.4 接受那些我们无法更改的食物：描述外部系统
一些子系统显然不在系统的任何bounded context中。一些无法立即淘汰的大型遗留系统和那些需要提供服务的外部系统就是这样的例子。我们识别出这些系统，并把它们与你的设计隔离开。
#### 14.13.5 与外部系统的关系
首先考虑的是独立自主（separate way）模式。如果集成确实非常重要，可以在两种极端跟随者（conformist）或防腐层（anticorruption layer）模式中选择一种。
#### 14.13.6 正在设计的系统
如果正在构建的软件实际上是一个正在设计的系统，可以在这个区域内声明bounded context，并在每个bounded context使用持续性集成。
每个bounded context都对应一个团队，一个团队可以维护多个bounded context，但多个团队在一个上下文中工作比较困难。
#### 14.13.7 满足不同模型的特殊需求
同一个业务不同业务小组常常有各自的专业术语，而且可能各自不同，这些本地术语可能非常精确，并且是根据他们需求定制，要想改变，需要大量培训。
如果采用不同的bounded context来满足这些特殊需求，除了转化层持续集成，模型层采用独立自主模式，让他们各自发展自己的行话。如果专业术语很多重叠之处，可以采用共享内核方式。
有时会出现一个深层次的模型，它把这些不同的语言统一起来，并能满足双方的要求。
#### 14.13.8 部署
#### 14.13.9 权衡
通过总结这些指导原则可知由很多统一或集成模型的策略，一般来说我们需要在集成益处和额外协调沟通工作之间做出权衡，在独立操作和顺畅沟通之间做权衡。
#### 14.13.10 当项目正在进行时
首先，根据当前的状况来定义bounded context以及它们的关系，下一步就是围绕当前组织结构来加强团队的工作，在context中持续性集成。最后可以考虑修改边界和它们的关系了。
### 14.14  转换
在很多情况下，我们必须改变最初有关边界以及bounded context之间关系的决策，这是不可避免的。一般而言，分割context是很容易的，但合并它们或改变它们之间的关系却很难。
#### 14.14.1 合并context：separate way -> shared kernel
这种合并的前提是：翻译开销太高、重复现象明显等等。这种合并很难完成，需要一些耐心。

1. 评估初始状况
2. 建立合并过程
3. 选择某个小的领域作为开始，它应该是在两个context中重复出现的子领域
4. 选择某个小的子领域作为开始，它应该是在两个context中重复出现的子领域
5. 从两个团队中选出2-4位开发人员组成一个小组，由他们为子领域开发一个共享模型。
6. 来自两个团队的开发人员一起负责实现模型。
7. 每个团队的开发人员都承担与新的shared kernel集成的任务。
8. 清除那些不再需要的翻译

如果两个模型各自采用了不用用户群的专业术语，聪明的做法是先不要把他们合并到shared kernel中，除非工作中出现突破，得到了一个深层次的模型。
#### 14.14.2 合并context：shared kernel-> continuous integration
如果你的shared kernel正在扩大，你可能会被统一两个bounded context的优点所吸引。这并不只是一个解决模型差异的问题，将改变团队结构。

1. 确保每个团队都已经建立了continuous integration所需的所有过程。
2. 团队成员在团队之间流动。这样可以形成一大批同时理解两个模型的人员。
3. 澄清每个模型的精髓。
4. 现在团队有了足够的信心把核心领域合并到shared kernel中，这可能需要多次迭代。合并过程最好能快速完成，但注意量力而行，不要超过你的处理能力。
5. 随着shared kernel的增长，把集成频率提高到每天一次，最后实现continuous integration。
6. 当shared kernel逐渐把先前的bounded context的所有内容包括进来时，会发现要么形成一个大的团队，要不形成两个小团队，这两个小团队有一个continuous context代码库。
#### 14.14.3 逐步淘汰遗留系统
一个事物再好，也会有一个尽头，遗留计算机软件也不例外。但这种现象并不是光靠这个事物自己发生的。这些老的系统可能与业务及其他系统紧密交织在一起，因此淘汰它们可能需要更多年。
这一话题涉及面太广了，这里的讨论也只能浅尝辄止。
#### 14.14.4 open host service-> published language
随着需要访问的系统逐渐增多，维护负担也在不断增加，或者交互变得很难理解。我们需要通过published language来规范系统之间的关系。

- 如果有一种行业标准语言可以用，则尽可能评估并使用它。
- 如果没有标准语言或预先公开发布的语言，则对系统的core domain进行完善，作为交换语言基础，尽可能使用例如XML这样的交互标准范式。

published language必须是稳定的。

## 第15章 精炼
精炼是把一堆混杂在一起的组件分开的过程，以便从中提取出最重要的内容，使得它更有价值，也更有用。模型就是知识的精炼。通过每次重构得到更深层次的理解，我们把关键的领域知识和优先级提取出来。
精炼的主要动机是把最有价值的那一部分提取出来，正是这部分使我们软件区别于别的软件，而且由于这个部分的存在才值得我们去构建软件，这个部分就叫做core domain。
### 15.1 模式：core domain
在设计大型系统时，有很多有用的组件，它们都很复杂而且绝对有必要把它们做好，这导致真正的业务资产-领域模型-被掩盖和忽略了。
**一个严峻的现实**是我们不可能对所有设计部分进行同等的精华，而是必须分出优先级。为了使领域模型成为有价值的资产，必须整齐地梳理出模型真正的核心，并完全根据这个核心来创建应用程序的功能。但本来就稀缺的高水平开发人员往往会把工作重点放在技术基础设施上，或者只是区解决那些不需要领域知识就能理解的领域问题。
对模型进行提炼，找到core domain并提供一种易于区分的方法把它那些起辅助作用的模型和代码区分开。最有价值和最专业的概念要轮廓分明。尽量压缩core domain。
让最有才能的人来开发core domain，并相应地招募新人来补充这些人空出来的位置。在core domain中努力开发能够确保实现系统蓝图的深层模型和肉型设计。仔细判断任何其它部分的投入，看它是否能够支持这个提炼出来的core。

#### 15.1.1 选择核心
我们需要关注的那些能够表示业务领域并解决业务问题的模型部分。
#### 15.1.2 工作分配
建立一支由开发人员和一位或多位领域专家组成的联合团队，其中开发人员必须能力很强、能够长期很强、稳定地工作并且对学习领域知识非常感兴趣，而领域专家则必须要掌握深厚的业务知识。
从外界聘请一些短期的专业人员来设计core domain的关键环节通常是行不通的，因为团队需要积累领域知识，而短期人员会造成知识流失。
### 15.2  精炼的逐步提升
一份简单的domain vision statement（领域前景说明）只需要很少的拖入，它传达了基本概念以及他们的价值。highlighted core（突出的核心）可以改善沟通，并指导决策制定过程。
更积极的精炼方法是通过重构喝重新打包现式地分离出generic subdomain，然后分别进行处理。在使用cohesive mechanism的同时，也要保持设计的通用性、易懂性和柔性。
### 15.3 模式：generic subdomain
模型中有些部分除了增加复杂性以外并没有捕获或传递专门的知识，任何外来元素都会使core domain更难以分辨和理解。这些细节并不是我们主要关注点，而只是起到支持作用。
把内聚的子领域（它们并不是项目的动机）识别出来。把这些子领域的通用模型提取出来，并放到单独的module中。把它们分离出来以后，在继续开发的过程中，它们的优先级应低于core domain的优先级。
开发这样的软件包时，有以下几种选择：
选择1：现成的解决方案
选择2：公开发布的设计或模型
选择3：把实现外包出去
选择4：内部实现
#### 15.3.1 通用不等于可以重用
应该尽可能把大部分精力投入到core domain工作中，而只在必要的时候才支持性的generic subdomain中投入工作。
尽管我们很少需要考虑设计的可重用性，但通用子领域的设计必须严格地限定在通用概念的范围之内。如果把行业专用的模型元素引入到通用子领域中，会产生两个后果。第一，它将妨碍将来开发；第二这些行业专用概念要么属于core domain，要么属于它们自己更专业的子领域。
#### 15.3.2 项目风险管理
除非团队拥有精湛的技术并且对领域非常熟悉，否则第一个雏形系统应该以core domain的某个部分为基础，不管它多简单。
### 15.4 模式：domain vision statement（领域愿景描述）
写一份core domain的简短描述以及它将会创造的机制（大的一页纸），也就是“价值主张”。那些不能将你的领域模型与其他领域模型区分开的方面就不要写了。展示出领域模型是如何实现喝均衡各方利益的。这份描述要尽量精简。尽早把它写出来，等到获得新的理解再修改它。

### 15.5 模式：highlighted core（精炼文档）
#### 15.5.1 精炼文档
编写一个非常简短的文档（3-7页，每页内容不必太多），用于描述core domain以及core元素之间的主要交互。
#### 15.5.2 标明core
把模型的主要存储库中的core domain标记出来，而不要特意去阐明其角色。使开发人员很容易就知道什么在核心内，什么在核心外。
#### 15.5.3 把精炼文档作为过程工具
如果精炼文档概括了core domain的基本元素，那么它就可以作为一个指示器来指示模型改变的重要程度。当模型或代码的修改影响到精炼文档时，需要与团队其它成员一起协商。
### 15.6 模式：cohesive mechanism（内聚机制）
计算有时候会非常复杂，使设计开播变得膨胀。机制性的“如何做”大量增加，而把概念性的“做什么”完全掩盖了。为解决问题提供算法的大量方法掩盖了那些用于表达问题的方法。
把概念上的cohesive mechanism（内聚机制）分离到一个单独的轻量级框架中。领域中的其他元素就可以只专注于如何表达问题（做什么）了，而把解决方案的复杂细节（如何做）转移给了框架。
#### 15.6.1 generic subdomain与cohesive mechanism的比较
generic subdomain与cohesive mechanism的动机都是相同的--为core domain减负。cohesive mechanism并不表示领域，它的目的是解决描述性模型提出的一些复杂问题。
#### 15.6.2 mechanism是core domain一部分
我们几乎总是想要把mechanism从core domain中分离出去。一个例外mechanism本身就是一个专有部分并且是软件一项核心价值。有时，非常专用的算法就是这种情况。
### 15.7 通过精炼得到声明式风格
精炼的价值在于使你能够看到自己正在做什么，不让无关细节分散你的注意力，并通过不断消减得到核心。如果领域中那些起到支持作用的部分提供了一种简练的语言，可用于表示core概念和规则，同时又能够吧计算或实施这些概念和规则的方式封装起来，那么core domain的重要部分就可以采用声明式设计。
### 15.8 模式：segregated core
通过把generic subdomain提取出来，可以从领域中清除一些干扰性喜剧，使core变得更清楚。
对模型进行重构，把核心概念从支持性元素（包括定义的不清楚的那些元素）中分离出来，并增强core的内聚性，同时减少它与其他代码耦合。把所有通用元素或支持性元素提取到其他对象中。并把这些对象放到其他包中--即使这会把一些紧密耦合的元素分开。
#### 15.8.1 创建segregated core的代价
segregated core使我们能够提高core domain的内聚性。
另一个代价是隔离core需要付出很大的工作量。我们必须认识到，在做出segregated core的决定时，有可能需要开发人员对整个系统做出修改。
#### 15.8.2 不断发展演变的团队决策
新的理解必须不断地在整个团队中共享，但个人不能单方面根据这些理解擅自采取行动。无论团队采用了什么样的决策过程，团队一致通过也好，由领导下命令决定也好，决策过程都必须有足够的敏捷性，可以反复纠正。团队必须进行有效的沟通，以便使每个人都共享同一个core视图。
### 15.9 模式：abstract core
把模型中最基本的概念识别出来，并分离到不同的类、抽象类或接口中。设计这个抽象模型，使之能够表达出重要组件之间的大部分交互。把这个完整的抽象模型放到它自己的module中，而专用的、详细的实现类则留在由子领域定义的module中。
### 15.10 深层模型精炼
尽管任何一个突破都会得到一个有价值的深层模型，但只有core domain中的突破才能改变整个项目的轨道。
### 15.11 选择重构目标
如果采用“哪儿痛治哪儿”这种重构策略，要观察一下根源问题是否涉及core domain或core与支持元素的关系。如果确实涉及，那么就要接受挑战，首先修复核心。
当可以自由选择重构部分时，应首先集中精力把core domain更好提出出来，完善对core的隔离，并且支持性的子领域提炼成通用子领域。

第16章  大比例结构
在一个大的系统中，如果因为缺少一种全局性的原则而使人们无法根据元素在模式（这些模式被应用于整个设计）中的角色来解释这些元素，那么开发人员会陷入“只见树木，不见森林”的境地。
“大比例结构”是一种语言，人们可以用它来从大局上讨论和理解系统。
设计一种应用于整个系统的规则（或角色和关系）模式，使人民可以通过它在一定程度上了解各部分在整体中所处的位置（即使是在不知道各部分的详细指责的情况下）。
16.1 模式：evolving order（进化的规则）
概念上的大比例结构随着应用程序一起演变，甚至可以变成一种不同的结构风格。有些设计决策和模型决策必须在掌握了详细知识后才能确定，这样的决策不必过早的制定。
在选择大比例结构时，应该侧重于整体模型的易管理性，而不是优化个别部分的结构。在此，在“统一使用结构”和“用最自然的方式表示个别组建”之间需要做出一些折中选择。
当发现一种大比例结构可以明显使系统变得更清晰，而又没有为模型开发施加一些不自然的约束时，就应该采用这种结构。使用不合适的结构还不如不使用它，因此最好不要为了追求设计的完整性而勉强去使用一种结果，而应该找到能够最精简地解决所出现问题的方案。要记住宁缺毋滥的原则。
16.2 模式：system metaphor（系统隐喻）
软件设计往往非常抽象且难于掌握。开发人员和用户都需要一些切实可行的方式来理解系统，并共享系统的一个整体视图。
当系统的一个具体类比正好符合团队成员对系统的想象，并能有引导他们向着一个有用的方向进行思考时，就应该把这个类比用作一个大比例结构。围绕这个隐喻来设计组织，并把他吸收到ubiquitous language中。
system metaphor并不适用于所有项目。从总体上讲，大比例结构并不是必须使用的。
16.3 模式：responsibility layer
如果每个对象的职责都是手工分配的，将没有统一的指导原则和一致性，也无法把领域作为一个整体来处理。为了保持大模型的一致，有必要在职责上实施一定的结构化控制。
