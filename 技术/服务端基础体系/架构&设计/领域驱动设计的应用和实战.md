## DDD开章篇
#### 业务架构师
架构师=技术大牛？
架构师能力
#### 要能够将业务转化转化为技术
对业务及其痛点：有深刻的理解和思考，分析业务流程；理解业务规则；挖掘业务痛点；
**能合理运用技术支撑业务**
将技术落地产生业务价值，规划高远确落不了地；快速研发产生业务价值；
**关键难题**
如何快速有效地学习业务领域知识
如何深入地理解与挖掘业务痛点
如何通过技术的手段落地业务
#### 软件发展
**软件发展规律**
软件是对真实世界的模拟，但真实世界十分复杂；人在认识真实世界的时候总是有一个从简单到复杂的过程；因此软件需求变更成为一种必然，而且总是由简单向复杂转变；起初软件的业务逻辑非常简单清晰明了，慢慢变得越来越复杂
**软件退化的根源**
需求变更->解耦/扩展->实现需求->高质量代码
需求变更->没有调整->实现需求->软件退化
#### 领域驱动如何落地
怎样正确地进行业务领域建模
怎么将领域转换成程序设计
支持领域驱动设计的架构设计

## 领域驱动理论篇
#### 战术工具
抽象，分治，知识，聚合，实体对象，值对象，领域服务，领域事件，微领域，流程模版等，工具是可以拓展、变化、升级等跟我们业务场景做适配的。
#### 战略建模
界限上下文，核心域，通用子域，支撑子域
#### 领域
领域与具体技术无关，是系统要解决所有问题的集合。
核心域： 业务成功的主要因素，主要竞争力。核心域的开发最高的优先级和最优秀的开发团队。
通用子域：业务系统的公共部分。
支撑子域：支撑核心域，而通用子域是业务系统的公用部分
#### 界限上下文
限界上下文包含的是一个系统、一个应用、一种业务服务以及一系列实现业务的复杂组件。
#### 通用语言
限界上下文中的每种领域术语、词组、或者句子都叫做通用语言，无论是领域专家和开发人员在对领域问题的沟通、需求的讨论，开发计划的制定、概念、还是代码中出现的类名与方法，都包括其中，而且要注意的一个规则是：只要是相同的意思，就应该使用相同的词汇。可以看出，这种通用语言不是一下子就可以形成，而是在一个各方人员的讨论中，不断发现、明确与提炼出来的。
#### 领域模型
领域模型其实就是把通用语言表达成软件模型，领域模型包括了模块、聚合、领域事件和领域服务等概念。
#### 服务/实体/值对象
服务：领域建模中标识某些行为或操作
实体：领域建模中由一个标识唯一区分的领域对象
值对象：领域建模中没有标识唯一区分的领域对象
#### 领域服务
有些领域中的动作，它们是一些动词，看上去却不属于任何对象。它们代表了领域中的一个重要的行为，此时我们便应该将该操作放在一个单独的接口中。并且保证它是无状态的。例如跨领域的动作，先支付再扣流量。
#### 领域事件
领域专家所关心的发生在领域中的一些事情。是领域模型的组成部分，表示领域中所发生的事情。
聚合上每一个命令方法都会产生事件吗？与何时需要使用领域事件同等重要的是，我们需要知道何时不应该使用领域事件。
事件即事实（Event as Fact）(奈学教育DDD课程)：领域事件即领域中发生的事实，在真实世界中，当满足某个条件时，某个发起者触发的某个事件，做某个事情。事实是指那些已经发生过的事情。
事件即事实，即在业务领域中那些已经发生的事件就是事实，并可能需要保存下来或者让“别人”响应。(Something that happened that people Care About.)
#### 聚合和非聚合
聚合是一个用来定义对象所有权和边界的领域模式。每个聚合都有一个根，这个根是一个实体，并且它是外部可以访问的唯一对象。

- 聚合是用来封装真正的不变性，而不是简单的将对象组合在一起；
- 聚合应尽量设计的小；
- 聚合之间的关联通过ID，而不是对象引用；
- 聚合内强一致性，聚合之间最终一致性；

#### 单一职责原则（SRP）
单一职责原则要求一个接口或类只有一个原因引起变化，也就是说一个接口或一个类只有一个原则，它就只负责一件事 
#### 工厂
DDD中引入工厂模式的原因是：有时创建一个领域对象是一件比较复杂的事情，不仅仅是简单的new操作。正如对象封装了内部实现一样（我们无需知道对象的内部实现就可以使用对象的行为），工厂则是用来封装创建一个复杂对象尤其是聚合时所需的知识，工厂的作用是将创建对象的细节隐藏起来。
#### 仓储（Repository）

- 领域模型中的对象自从被创建出来后不会一直留在内存中活动的，当它不活动时会被持久化到数据库中，然后当需要的时候我们会重建该对象。
- 仓储里面存放的对象一定是聚合。
- 仓储还有一个重要的特征就是分为仓储定义部分和仓储实现部分，在领域模型中我们定义仓储的接口，而在基础设施层实现具体的仓储。
- 尽管仓储可以像集合一样在内存中管理对象，但是仓储一般不负责事务处理。一般事务处理会交给一个叫“工作单元（Unit Of Work）”的东西。
- 仓储在设计查询接口时，可能还会用到规格模式（Specification Pattern），例如LINQ以及DLINQ查询
#### _聚合与事件源（A+ES）_
![image.png](https://cdn.nlark.com/yuque/0/2022/png/8364057/1647845256396-a3dcf301-fd21-4785-bc58-e3e470315c66.png#clientId=ucfec8db3-2fab-4&from=paste&height=123&id=uf7934a5c&originHeight=246&originWidth=1524&originalType=binary&ratio=1&size=241271&status=done&style=none&taskId=u21ab6400-8c1a-41a0-8d2e-34787a37a6d&width=762)
_以事件流的方式，表示一个聚合。按照事件产生的顺序重放这些事件，以追加的方式向事件流尾部添加事件。_

---

## DDD实践设计篇

#### 贫血模型设计

- 失血模型：模型仅仅包含数据的定义和getter/setter方法，业务逻辑和应用逻辑都放到服务层中。这种类在java中叫POJO，在.NET中叫POCO。
- 贫血模型：贫血模型中包含了一些业务逻辑，但不包含依赖持久层的业务逻辑。这部分依赖于持久层的业务逻辑将会放到服务层中。可以看出，贫血模型中的领域对象是不依赖于持久层的。
#### 充血模型设计
充血模型中包含了所有的业务逻辑，包括依赖于持久层的业务逻辑。所以，使用充血模型的领域层是依赖于持久层，简单表示就是UI层->服务层->领域层<->持久层
#### 
#### 事件风暴建模
**什么是事件风暴**
【官方】已经总结的极好。以下为官方内容的翻译版本：事件风暴是一种以协作探索复杂业务领域为目标的，灵活的工作坊（workshop）形式的活动。

**事件风暴与DDD的关系**
DDD是以强调领域为核心的应对复杂业务系统的一套体系。或者说是业务系统控制设计质量的领域逻辑设计方法。而事件风暴是探索业务领域的很好的一种实践方式，事件风暴的产出对应类DDD的统一语言和战略设计中的领域分析，到划分限界上下文。

**适用场景**

- 发掘现有的健康业务线中最有改进价值的地方
- 探索新业务模式的可行性
- 设想新的服务，为每个参与方带来最好的正向结果
- 设计整洁可维护的事件驱动型（Event-Driven）软件，以支持快速发展的业务

事件风暴的适应性，决定了它允许有不同背景的项目干系人进行复杂的，跨学科的沟通交流，提供了一种跨越信息孤岛和专业界限的新型协作方式。

**事件Event**
事件即事实，在业务领域中已经发生的事件就是事实。并可能需要保存下来或者让“别人”响应。如：用户已注册，邮件已发送

**决策命令Command**
决策命令产生了事件，可理解为产生事件的动作，与事件一一对应。如用户已注册事件对应的决策命令就是注册用户。

**发起命令的参与者User/Actor**
决策命令一定是由某个人/系统发起的。

**读模型Read Model**
某个Actor做出决策命令Command的前提是需要看到某些信息，或者说，支持Actor更容易做出决策命令Command的信息。一般通过页面来展示更多的信息，让用户更容易做出决策。

**聚合Aggregate**

**外部系统External System和规则Policy**
事件不一定是某个Actor触发Command而产生，也可能是由外部系统或者某种规则自动触发而产生。

**整体解释**
一个Actor根据看到的Query Model/Information，决定对External System或者Aggregate执行一个Command/Action，进而产生了某种Domain Event。
此Domain Event可能触发了某种Policy，此Policy可能又对External System或者Aggregate执行一个Command/Action。此Domain Event也可能会导致Query Model/Information发生变化，从而给Actor提供更多信息以进行其他操作。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/8364057/1647858599015-226dfe30-0823-4f3f-8ce3-96ca7bd500bb.png#clientId=ucfec8db3-2fab-4&from=paste&height=413&id=u0c14abcd&originHeight=825&originWidth=720&originalType=binary&ratio=1&size=395410&status=done&style=none&taskId=ufbc60ec2-ed2f-4b17-a9ce-3ad4ce61e04&width=360)

**事件风暴适用场景**
经过实践，我认为事件风暴不适合多于6个人以上的团队，人太多参与感会降低，效果会下降很多。如果是大型项目，取决于事件风暴的目的，可能需要将项目提前进行拆分，以让负责某项功能特性的小团队单独做事件风暴。

#### 事件风暴建模流程
**提前准备**
邀请产品/业务/研发/测试，控制人数4-6人为宜，提起预定会议室（有白板），准备马克笔、不同颜色贴纸等。
**事件风暴过程1**
介绍事件风暴的意义、目的、流程，产品经理介绍本次迭代的版本信息。
**事件风暴过程2**
从产品定义和运营角度，列出所有的事件
**事件风暴过程3**
从第一个事件开始，梳理事件是怎么产生的，actor、命令、policy等添加进去。
**事件风暴过程4**
添加读模型Read Model
**事件风暴过程5**
添加聚合，以聚合为核心，将关系密切的聚合以及相关事件等内容移动到一起，但整体仍是按照时间排序的。
**事件风暴过程6**
分析并划分出子域，识别核心域、支撑域与通用域。


#### 四色建模法
**定义**
将抽象出来的领域对象分成四种原型：
时间原型：表示某时刻或时间段内发生的某个活动，用粉色标识
角色原型：表示某个人（或事物）以某种角色参与某个事件，用黄色表示，称为Role
参与者-地点-物品原型：表示事件相关的任务、地点、物品用绿色表示，简称PPT
描述原型：对PPT原型的描述，用蓝色标识
![image.png](https://cdn.nlark.com/yuque/0/2022/png/8364057/1647327667291-0ef386bf-5279-4a50-99fa-ddff8204e00b.png#clientId=ue54f88bf-bfb9-4&from=paste&height=170&id=uT2Ng&originHeight=340&originWidth=1518&originalType=binary&ratio=1&size=444424&status=done&style=none&taskId=u80940bcf-9640-4e31-b460-adb05273dbb&width=759)

**步骤**

1. 找到溯源事件
2. 确定时标型对象
3. 找到周围的PPT对象
4. 找到角色
5. 补全描述对象

#### 如何确定聚合
需要从业务的角度深入分析哪些对象它们的关系是内聚的，即我们会把他们看成是一个整体来考虑的；然后这些对象我们就可以把它们放在一个聚合内。所谓关系是内聚的，是指这些对象之间必须保持一个固定规则，固定规则是指在数据变化时必须保持不变的一致性规则。当我们在修改一个聚合时，我们必须在事务级别确保整个聚合内的所有对象满足这个固定规则。作为一条建议，聚合尽量不要太大，否则即便能够做到在事务级别保持聚合的业务规则完整性，也可能会带来一定的性能问题。有分析报告显示，通常在大部分领域模型中，有70%的聚合通常只 有一个实体，即聚合根，该实体内部没有包含其他实体，只包含一些值对象；另外30%的聚合中，基本上也只包含两到三个实体。这意味着大部分的聚合都只是一个实体，该实体同时也是聚合根。
#### 工厂（Factory）/仓库（Repository）

#### 跨库关联关系查询
建立关联表，采用接口查询

---

## 软件架构如何支持领域驱动
#### 架构价值
> #### 架构是软件系统的一部分，所以要明白架构的价值，首先要明确软件系统的价值。软件系统的价值有两方面，行为价值和架构价值。
> 行为价值是软件的核心价值，包括需求的实现，以及可用性保障（功能性 bug 、性能、稳定性）。这几乎占据了我们90%的工作内容，支撑业务先赢是我们工程师的首要责任。如果业务是明确的、稳定的，架构的价值就可以忽略不计，但业务通常是不明确的、飞速发展的，这时架构就无比重要，因为架构的价值就是让我们的软件（Software）更软（Soft）。可以从两方面理解：
> - 当需求变更时，所需的软件变更必须简单方便。
> - 变更实施的难度应该和变更的范畴（scope）成等比，而与变更的具体形状（shape）无关。
> 
重要紧急矩阵中，做事的顺序是这样的：1.重要且紧急 > 2.重要不紧急 > 3.不重要但紧急 > 4.不重要且不紧急。实现行为价值的需求通常是 PD 提出的，都比较紧急，但并不总是特别重要；架构价值的工作内容，通常是开发同学提出的，都很重要但基本不是很紧急，短期内不做也死不了。所以行为价值的事情落在1和3（重要且紧急、不重要但紧急），而架构价值落在2（重要不紧急）。我们开发同学，在低头敲代码之前，一定要把杂糅在一起的1和3分开，把我们架构工作插进去

#### 编程范式
结构化编程、面向对象编程、函数式编程
#### 设计原则
架构的主要工作就是将软件拆解为组件，设计原则指导我们如何拆解、拆解的粒度、组件间依赖的方向、组件解耦的方式等。
> 开闭原则（OCP）：易于拓展，对修改抗拒
> 单一职责（SRP）：任何模块只对一个用户价值负责
> 里式替换（LSP）：当同一个接口的不同实现相互替换时，系统行为应该保持不变。
> 接口隔离（ISP）：不依赖不需要的方法、类或组件。
> 依赖反转（DIP）：跨越边界的依赖方向永远与控制流方向相反。

#### 组件设计原则
组件设计
> 复用、发布等同原则（REP）：软件复用的最小粒度等同于其发布粒度。直白地说，就是要复用一段代码就把它抽成组件。该原则指导我们组件拆分粒度。
> 共同复用原则（CRP）：不要强迫一个组件依赖它不需要的东西，是ISP在组件上的描述，该原则指导我们在组件拆分的粒度。
> 共同闭包原则（CCP）：为了相同的目的同时修改的类，应该放在一个组件中。CCP原则是CRP原则在组件层面的描述。
> 
> REP、CCP、CRP 三个原则之间存在彼此竞争的关系，REP 和 CCP 是黏合性原则，它们会让组件变得更大，而 CRP 原则是排除性原则，它会让组件变小。遵守REP、CCP 而忽略 CRP ，就会依赖了太多没有用到的组件和类，而这些组件或类的变动会导致你自己的组件进行太多不必要的发布；遵守 REP 、CRP 而忽略 CCP，因为组件拆分的太细了，一个需求变更可能要改n个组件，带来的成本也是巨大的。

组件依赖
> 无依赖环原则：健康依赖应该是一个有向无环图
> 稳定依赖原则：依赖必须要指向更稳定的方案，这里稳定性指的变更成本，影响变更成本最重要的因素是依赖它的组件数量。组件稳定性的定量化衡量指标是：不稳定性（I） = 出向依赖数量 / (入向依赖数量 + 出向依赖数量)
> 稳定抽象原则：一个组件的抽象化程度应该与其稳定性保持一致。为了防止高阶架构设计和高阶策略难以修改，通常抽象出稳定的接口、抽象类为单独的组件，让具体实现的组件依赖于接口组件，这样它的稳定性就不会影响它的扩展性。组件抽象化程度的定量化描述是：抽象程度（A）= 组件中抽象类和接口的数量 / 组件中类的数量。


#### 组件划分
**组件定义**
首先要给组件下个定义：组件是一组描述如何将输入转化为输出的策略语句的集合，在同一个组件中，策略的变更原因、时间、层次相同。从定义就可以看出，组件拆分需要在两个维度进行：按层次拆分、按变更原因拆分。
**组件依赖**
组件分好了层，依赖就很好处理了：依赖关系与数据流控制流脱钩，而与组件所在层次挂钩，始终从低层次指向高层次，如下图。越具体的策略处在的层级越低，越插件化。切换数据库是框架驱动层的事情，接口适配器完全无感知，切换展示器是接口适配器层面的事情，用例完全无感知，而切换用例也不会影响到业务实体。
**组件边界**
一个完整的组件边界包括哪些内容？首先跨越组件边界进行通信的两个类都要抽象为接口，另外需要声明专用的输入数据模型、声明专用的返回数据模型，想一想每次进行通信时都要进行的数据模型转换，就能理解维护一个组件边界的成本有多高。
除非必要，我们应该尽量使用不完全边界来降低维护组件边界的成本。不完全边界有三种方式：

- 省掉最后一步：声明好接口，做好分割后，仍然放在一个组件中，等到时机成熟时再拆出来独立编译部署。
- 单向边界：正常的边际至少有两个接口，分别抽象调用方和被调用方。这里只定义一个接口，高层次组件用接口调用低层次组件，而低层次组件直接引用高层次组件的类。
- 门户模式：控制权的间接转移不用接口和实现去做，而是用门户类去做，用这种方式连接口都不用声明了。
#### 架构模型
**分层架构**
![image.png](https://cdn.nlark.com/yuque/0/2022/png/8364057/1647942426872-b64718a6-e23a-4fd4-a584-03ab41f64309.png#clientId=ucfec8db3-2fab-4&from=paste&height=277&id=ufbc922b4&originHeight=553&originWidth=628&originalType=binary&ratio=1&size=36623&status=done&style=none&taskId=u5d2f9c90-9d13-4836-882e-5c7375daf4e&width=314)
**洋葱圈模型**
![image.png](https://cdn.nlark.com/yuque/0/2022/png/8364057/1647941273720-2fc7a0b3-7746-4d3a-acd5-8b1257219400.png#clientId=ucfec8db3-2fab-4&from=paste&height=250&id=ua50cfcb5&originHeight=499&originWidth=720&originalType=binary&ratio=1&size=143719&status=done&style=none&taskId=u30d98ae6-4b2f-4292-ae07-fb866d1b697&width=360)
**六边形架构**
![image.png](https://cdn.nlark.com/yuque/0/2022/png/8364057/1647942574828-ce7393cb-f0e8-4ab9-bf8b-70200a1065a8.png#clientId=ucfec8db3-2fab-4&from=paste&height=295&id=ueab2322e&originHeight=590&originWidth=721&originalType=binary&ratio=1&size=160393&status=done&style=none&taskId=u02148737-1ae5-40a4-9633-6e69fdf4bc3&width=360.5)

## 参考
[什么是DDD](https://zhuanlan.zhihu.com/p/361427612)
[领域驱动编码实践](https://mp.weixin.qq.com/s/g1i04xjUgkqLOqtTeFukgQ)
[事件风暴](https://zhuanlan.zhihu.com/p/399103071)
[四色建模](https://zhuanlan.zhihu.com/p/381859443)
[架构简洁之道](https://zhuanlan.zhihu.com/p/68823394)
[DDD—分层架构、洋葱架构、六边形架构](https://www.cnblogs.com/jiyukai/p/14830869.html)
