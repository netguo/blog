#### 序&前沿
1. 一个好的领域模型可以控制软件开发的复杂性
2. 领域模型的最大价值是它提供了一种通用语言，这种语言是将领域专家和技术人员联系在一起的纽带。
3. 领域模型并不是按照“先建模，后实现”这个次序来工作的。像很多人一样，作者也反对“先设计，再构建”这种固定的思维模式。真正强大的领域模型是随着时间演进的，即使是最有经验的建模人员也往往发现他们是在系统的初始版本之后才有更好的想法。
4. 很多因素可能会导致项目偏离轨道，如官僚主义、目标不清、缺乏资源，等等。但真正决定软件复杂性的是设计方法。当复杂性失去控制时，开发人员就无法更好地理解软件，因此无法轻易、安全的更改和扩展它。
5. 设计和过程是密不可分的，设计思想必须被成功的实现，否则就是纸上谈兵。
6. 实际上，XP最适合那些对设计的感觉很敏锐的开发人员。XP过程假定人们可以通过重构来改进设计，而且可以经常、快速完成重构。

#### 第一部分 让领域模型发挥作用

每个软件程序的目的都是为了执行某项活动，或是满足用户的某种需求。用户会把软件程序应用于某个主题区域，这个区域就是软件的领域。
模型是用于解决信息超载问题的工具。模型是一种知识形式，它对知识进行有选择的简化和有目的的结构化。
领域模型并非一种特殊的图，而是图要表达的思想。它绝不单单是领域专家头脑中的知识，而是经过严格组织并精心选择的抽象知识。
**模型在领域驱动设计中的作用**
* 模型和设计的核心相互影响
* 模型是团队所有成员所使用的交流语言的中枢
* 模型是浓缩的知识

**软件的核心**
* 软件的核心是其为用户解决领域相关的问题的能力
* 技术人才更愿意从事精细的框架工作，试图用技术解决领域问题。他们把学习领域知识和领域建模的工作留个别人去做。软件核心的复杂性需要我们直接去面对和解决，如果不这样做，必将导致工作重点的偏离。（开发人员往往会走两条偏路，过度重视技术和沉溺重复性工作）

##### 第一章：消化知识
1.1 有效建模的要素
* 1） 模型和实现的绑定
* 2） 获得了一种基于模型的语言
* 3） 开发一个蕴含丰富知识的模型
* 4） 提炼模型
* 5） 头脑风暴和实验

1.2 知识消化
高效的领域建模人员是知识的消化者。他们在大量信息中探寻有用的部分。他们不断尝试各种信息组织方式，努力寻找对大量信息有意义的简单视图。
知识消化并非一项孤立的活动，它一般是在开发人员的领导下，由开发人员与领域专家组成的团队来共同协作。他们共同收集信息，并通过消化而将它组织为有用的形式。

1.3 持续学习
当开始编写软件时，其实我们所知甚少。
高效率的团队需要有意识地积累知识，并持续学习。
善于自学的团队成员是团队中的中坚力量，那些涉及最关键领域的开发任务要靠他们来攻克。

1.4 知识丰富的设计
知识消化所产生的模型能够反映出对知识的深层理解。

1.5 深层模型
有用的模型很少停留在表面层次上。随着对领域和应用程序需求的理解逐步加深，我们往往会丢掉那些最初看起来很重要的表面元素，或者切换它们的角度。这时，一些在开始时不可能发现的巧妙抽象就会渐渐浮出水面，而它们恰恰切中问题的要害。
知识消化是一种探索，它永无止境。

##### 第二章：语言的交流和使用
领域模型是软件项目的公共语言的核心。模型是人们头脑中形成的与项目有关的概念集合，它用术语和关系反映了领域的深层含义。这些术语和相互关系提供了模型语言的语义，模型语言是专门为领域量身裁剪的，而且十分精确，以便支持技术开发。它是一条至关重要的纽带，将模型与开发活动结合在一起，并使模型与代码紧密绑定。

***2.1 模式：UBIQUITOUS LANGUAGE***
如果语言支离破碎，项目必将遭遇严重的问题。领域专家使用他们自己的行话，而技术团队成员使用自己的语言来从设计角度讨论领域。
日常讨论所使用的术语与代码中使用的术语不一致。甚至同一个在讲话和写东西使用的语言也不一致，这导致的后果是，即使人们对领域有一些深刻的描述，也转眼就忘记了，无法记录到代码或文档中。
翻译使得沟通不畅，并导致知识消化变得困难。
然而任何一种行话都不能成为公共语言，因为它们无法满足所有的需求。
当有些概念无法用现有语言中的词汇表达时，新的词语将被引入讨论中。
小结:一个团队需要统一建模语言

***2.2 “大声的” 建模***
精化模型的最佳方式之一就是通过对话来研究，找出可能的模型变化，并试着大声说出对它们的多种构想。这样不完善的地方很容易被听出来。
讨论系统时要结合模型。使用模型的元素以及模型中各元素之间的交互来大声描述场景，并且按照模型允许的方式将各种概念结合到一起。找到更简单的表达方式来讲出你要讲的话，然后将这些新的思想应用到图和代码中。

***2.3 一个团队，一种语言***
如果连经验丰富的领域专家都不能理解模型，那么模型一定是有问题。
![964b1a1d5853ac88ea5e6124a6e786be.png](evernotecid://9AF2AA47-F8FE-4FE8-B0F1-1F56D983AAF8/appyinxiangcom/23512927/ENResource/p12)
ubiquitous language使得，开发人员之间，领域专家之间的讨论，以及代码本身表达都是同一种语言。

***2.4 文档和图***
使用UML图表示整个模型和设计时，麻烦也随之而来，很多对象模型图在某些方面过于细致，同时在某些方面又有所遗漏。如果将所有编码的对象都放到建模工具中。细节过多的结果是“只见树木，不见森林”
想要把约束和断言包括进来，需要在UML图中使用文本，这些文本用括号括起来，放到图中。
图是一种沟通和解释手段，它们可以促成头脑风暴活动。简洁的小图能够很好的实现这些目标，而整个对象模型的综合性的大图反而失去了沟通或者解释能力，因为他们将读者淹没在大量细节中，使读者无法了解图的含义。
设计的重要细节应该在代码中提现出来。
两条用于评估文档的总体原则：
文档应作为代码和口头交流的补充：a.极限编程不主张使用过多的设计文档，让代码自己诠释它自己，但是这样有自己的局限性，它可能会让读代码的人淹没在细节中。b.口头讨论也是有自己的局限性，信息易丢失。c.文档不应再重复表示代码已经明确表达出的内容。
文档应努力寻求生存之道并保持最新：a.设计文档的最大价值是解释模型概念，帮助在代码的细节中指引方向。b.文档必须深入到各个项目活动中去。

***2.5 解释性模型***
驱动软件开发过程的技术模型必须是经过严格的精简，以便用最小化的模型实现其功能。

##### 第三章 绑定模型和实现
误区一：在一些领域驱动设计项目中，建立了领域模型，但是模型不能帮助开发设计成可运行的软件，导致开发者设计的软件与模型设计差异较大。
model-driven design要求，模型不仅仅能够指导早期的分析工作，还应该成为设计的基础。分析工作要抓住领域内的基础概念，并易于理解和表达的方式描述出来。
从模型中获取用于程序设计和基本职责分配的术语。让程序代码成为模型的表达，代码的改变可能会是模型的改变。而其影响势必要波及接下来相应的项目活动。
完全依赖模型的实现通常需要支持建模范式的软件开发工具和语言，比如面向对象编程。

误区二：编写代码的人员认为自己没有必要对模型负责，或者不知道如何让模型为应用程序服务，那么这个模型就和应用程序没有关联。模型将不再实用，分工阻断了设计人员和开发人员的协作，他们无法转达实现MODEL-DRIVEN DESIGN的种种细节。

HANDS-ON MODELER（亲身实践建模者）：任何参与建模的技术人员，不管在项目中主要职责是什么，都必须花时间了解代码。任何负责修改代码的人员必须学会用代码表达模型。参与不同工作的人都必须有意识的通过ubiquitous language与接触代码的人及时交换模型的想法。