### 推荐序
所谓控制就是对程序流转的与业务逻辑无关的代码或系统的控制
无论是微观世界的代码，还是宏观层面的架构，无论是三种编程范式还是微服务架构，它们都在解决一个问题——分离控制和逻辑的开始设计更灵活的系统，有的则开始简化和轻量化整个系统，这些高智商、经验足、不怕难的工程师们引领着整个行业前行。他们就是架构师！
架构设计是一门复杂的学问，要综合考虑编码、质量、部署、发布、运维、排障、升级等等各种因素，做出权衡，用最小的人力成本来满足构建和维护系统需求

计算机编程这50年里啊，编程语言稍微进步了一点，工具质量大大提升，但是计算机程序的基本构造没有什么变化。秘密在于，计算机代码没有变化，软件架构的规则也就一直保持了一致。软件架构的规则其实就是排列组合代码块的规则
写这本书就是为了讲述这些规则，这些永恒的、不变的软件架构规则。
### 第一部分  概述
做一个好的软件架构师所需要的自律和专注程度可能会让大部分程序员始料未及。
一旦软件架构做好了，维持系统正常运转再也不需要成群的程序员了；每个变更的实施也不再需要巨大的需求文档和复杂的任务追踪系统了；
采用好的软件架构可以大大节省软件项目构建与维护的人力成本。让每次变更都短小简单，易于实施，并且避免缺陷，用最小的成本，最大程度地满足功能性和灵活性的要求。
#### 第1章 设计与架构究竟是什么
一个好的软件设计终极目标是什么？软件架构的终极目标是，用最小的人力成本来满足构建和维护该系统的需求。
“架构”这个词往往使用于“高层级”的讨论中。这类讨论一般都把“底层”的实现细节排除在外。而“设计”一词，往往用来指代具体的系统底层组织结构和实现的细节。
架构图里实际上包含了所有的底层设计细节，这些细节信息共同支撑了顶层的架构设计，底层设计信息和顶层架构设计共同组成了整个房屋的架构文档。
底层设计细节和高层架构信息是不可分割的。它们组合在一起，共同定义了整个软件系统，缺一不可。所谓的底层和高层本身就是一系列决策组成的连续体，并没有清晰的分界线。
《伊索寓言》龟兔赛跑故事。这个故事的主题思想可以归纳为以下几种：

1. 慢但是稳，是成功的秘诀
2. 该比赛并不是拼谁开始跑的快，也不是拼谁更有力气
3. 心态越急，反而跑的越慢

某些软件研发工程师可能认为挽救一个系统的唯一办法是抛弃先有系统，设计一个全新的系统来替代。这里工程师仍然没有逃离过度自信，过度自信只会使得重构设计陷入和原项目一样的困局中。
#### 第2章 两个价值维度
艾森豪威尔的紧急/重要矩阵：紧急的和重要的，而紧急的难题永远是不重要的，重要的难题永远是不紧急的。
软件系统的第一个价值维度：系统行为，是紧急的，但是并不总是特别重要。
软件系统的第二个价值维度：系统架构，是重要的，但是并不总是特别紧急。

### 第二部分 从基础构件开始：编程范式
#### 第3章 编程范式总览
本章将讲述三个编程范式，它们分别是结构化编程（structured programming）、面向对象编程（object-oriented programming）以及函数式编程。
结构化编程对程序控制权的直接转移进行了限制和规范。
面向对象编程对程序控制权的间接转移进行了限制和规范。
函数式编程对程序中的赋值进行了限制和规范。
编程范式与软件架构的三大关注点不谋和：功能性、组件独立性以及数据管理。
#### 第4章 结构化编程
Dijkstra结论：编程是一项难度很大的活动。一段程序无论复杂与否，都包含了很多的细节信息。如果没有工具的帮助，这些细节的信息是远远超过一个程序员的认知能力范围的。而在一段程序中，哪怕仅仅是一个小细节的错误，也会造成整个程序出错。
顺序结构、分支结构、循环结构三种结构构造出任何程序。
**功能性降解拆分**
然结构化编程范式可将模块递归降解拆分为可推导的单元，这就意味着模块也可以按功能进行降解拆分。这样一来，我们就可以将一个大型问题拆分为一系列高级函数的组合，而这些高级函数各自又可以继续被拆分为一系列低级函数，如此无限递归。更重要的是，每个被拆分出来的函数也都可以用结构化编程范式来书写。
**测试**
测试只能展示Bug的存在，并不能证明不存在Bug，软件开发更像是一门科学研究学科，我们通过无法证伪来证明软件的正确性。

结构化编程范式促使我们先将一段程序递归降解为一系列可证明的小函数，然后再编写相关的测试来试图证明这些函数是错误的。如果这些测试无法证伪这些函数，那么我们就可以认为这些函数是足够正确的，进而推导整个程序是正确的。

#### 第5章 面向对象编程
究竟什么是面向对象？一种常见的回答“数据与函数的组合”，另一种常见的回答“面向对象编程是一种对真实世界进行建模的方式”。
任何一种面向对象编程，都必须支持，封装（encapsulation）、继承（inheritance）、多态（polymorphism），其隐含意思就是说面向对象编程是这三项的有机组合。
**封装**
这个特性其实并不是面向对象编程所独有的，Java和C#则彻底抛弃了头文件与实现文件分离的编程方式，这其实进一步削弱了封装性。因为在这些语言中，我们是无法区分一个类的声明和定义的。
**继承**
早在面向对象编程语言被发明之前，对继承性的支持就已经存在很久了。当然了，这种支持用了一些投机取巧的手段，并不像如今的继承这样便利易用，而且，多重继承（multiple inheritance）如果还想用这种方法来实现，就更难了。
虽然面向对象编程在继承性方面并没有开创出新，但是的确在数据结构的伪装性上提供了相当程度的便利性。
**多态**
归根结底，多态其实不过就是函数指针的一种应用。
采用面向对象编程语言让多态实现变得非常简单，我们认为面向对象编程其实是对程序间接控制权的转移进行了约束。
**小结**
面向对象编程就是以多态为手段来对源代码中的依赖关系进行控制的能力，这种能力让软件架构师可以构建出某种插件式架构，让高层策略性组件与底层实现性组件相分离，底层组件可以被编译成插件，实现独立于高层组件的开发和部署。

#### 第6章 函数式编程
函数式编程语言中的变量（Variable）是不可变（Vary）的。
案显而易见：所有的竞争问题、死锁问题、并发更新问题都是由可变变量导致的。如果变量永远不会被更改，那就不可能产生竞争或者并发更新问题。
**可变性隔离**
一个架构设计良好的应用程序应该将状态修改的部分和不需要修改状态的部分隔离成单独的组件，然后用合适的机制来保护可变量。
**事件溯源**
只存储事务记录，不存储具体状态，当需要具体状态时，我们从头开始计算所有事务。
### 第三部分 设计原则
一般情况下，我们为软件构建中层结构的主要目标如下：
使软件可容忍被改动。 使软件更容易被理解。 构建可在多个软件系统中复用的组件。
SOLID原则：SRP（单一职责原则）、OCP（开闭原则）、LSP（里氏替换原则）、ISP（接口隔离原则）、DIP（依赖反转原则）。
#### 第7章  SRP 单一职责原则
任何一个软件模块都应该只对一个用户（User）或系统利益相关者（Stakeholder）负责。
任何一个软件模块都应该只对某一类行为者负责。
单一职责原则主要讨论的是函数和类之间的关系，在组件层面可以称其为共同闭包原则，在软件架构层面，它则是用于奠定架构边界的变更轴心。
#### 第8章  OCP 开闭原则
设计良好的计算机软件应该易于扩展，同时抗拒修改。一个设计良好的计算机系统应该在不需要修改的前提下就可以轻易扩展。
软件架构师可以根据相关函数被修改的原因、修改的方式及修改的时间来对其进行分组隔离，并将这些互相隔离的函数分组整理成组件结构，使得高阶组件不会因低阶组件被修改而受到影响。
**信息隐藏**
“软件系统不应该依赖其不直接使用的组件”这一基本原则。
OCP是我们进行系统架构设计的主导原则，其主要目标是让系统易于扩展，同时限制其每次被修改所影响的范围。实现方式是通过将系统划分为一系列组件，并且将这些组件间的依赖关系按层次结构进行组织，使得高阶组件不会因低阶组件被修改而受到影响。
#### 第9章 LSP：里氏替换原则
如果对于每个类型是S的对象s都存在一个类型为T的的对象t，能使操作T类型的程序P在用t替换s时行为保持不变，我们可以将S称为T的子类型。
LSP可以且应该被应用于软件架构层面，因为一旦违背了可替换性，该系统架构就不得不为此增添大量复杂的应对机制。
#### 第10章 ISP：接口隔离原则
任何层次的软件设计，如果依赖了它不需要的东西，就会带来意外的麻烦。
#### 第11章 DIP：依赖翻转原则
如果想要设计一个灵活的系统，在源码层次的依赖关系中就应该多引用抽象类型，而非具体的实现。
显而易见把这条设计原则当作金科玉律来加以严格执行是不现实的，因为软件系统在实际构造中不可避免地需要依赖到一些具体的实现。例如String
**稳定的抽象层**
如果想要在软件架构设计上追求稳定，就必须多使用稳定的抽象接口，少依赖多变的具体实现。下面，我们将该设计原则归结为以下几条具体的编码守则：

- 应在代码中多使用抽象接口。
- 不要再具体实现类上创建衍生类。
- 不要覆盖具体的实现函数。

依赖关系跨越该边界的方向正好相反，源代码依赖方向永远是控制流方向的反转——这就是DIP被称为依赖反转原则的原因。
### 第四部分  组件构建原则
#### 第12章  组件
设计良好的组件都应该永远保持可被独立部署的特性，这同时也意味着这些组件应该可以被单独开发。
**组件发展史**
库函数包含到自己程序->重定位->链接器
**本章小节**
我们常常会在程序运行时插入某些动态链接文件，这些动态链接文件所使用的就是软件架构中的组件概念。在经历了50年的演进之后，组件化的插件式架构已经成为我们习以为常的软件构建形式了。
#### 第13章  组建聚合
三个构建组建相关的基本原则：
REP：复用/发布等同原则
CCP：共同闭包原则
CRP：共同复用原则
**复用/发布等同原则**
软件复用的最小粒度应等同于其发布的最小粒度。
一个组件不能由一组毫无关联的类和模块组成，它们之间应该有一个共同的主题或者大方向。
**共同闭包原则**
CCP原则也认为一个组件不应该同时存在着多个变更原因。总而言之，CCP的主要作用就是提示我们要将所有可能会被一起修改的类集中在一起。
由于100%的闭包是不可能的，所以我们只能战略性地选择闭包范围。
与SRP(单一职责)原则的相似点：在SRP原则的指导下，我们将会把变更原因不同的函数放入不同的类中。而CCP原则指导我们应该将变更原因不同的类放入不同的组件中。
**共同复用原则**
该原则建议我们将经常共同复用的类和模块放在同一个组件中。
CRP原则实际是在指导我们：不是紧密相连的类不应该被放在同一个组件中。
**组件聚合张力图**
REP和CCP原则是黏性原则，它们会让组件变得更大，而CRP原则是排除性原则，它会尽量让组件变小。软件架构师的任务就是要在这个三个原则中进行取舍。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/8364057/1659514084054-9eede513-f65e-4eaf-8455-ae561345cdb7.png#averageHue=%23fafafa&clientId=ub0ab8056-e0f2-4&from=paste&height=212&id=uc15a5b65&originHeight=684&originWidth=1050&originalType=binary&ratio=1&rotation=0&showTitle=false&size=72886&status=done&style=none&taskId=ub4baced6-6b8b-4a30-9bc2-7d458682d54&title=&width=326)
一个项目在组件结构上设计的重心是根据该项目的开发时间喝成熟度不断变动的。
#### 第14章 组件耦合
接下来讨论的三条原则主要关注的是组件之间的关系。
**无依赖环原则**
组件依赖关系中不应该出现环
**稳定依赖原则**
依赖关系必须要指向更稳定的方向
稳定性指标：

- Fan-in：入向依赖，这个指标指外部类依赖内部类的数量
- Fan-out：出向依赖，这个指标指内部类依赖外部类的数量
- I：不稳定性：I = Fan-out/(Fan-in + Fan-out)。[0,1]，0最稳定，1最不稳定。

并不是所有组件都应该是稳定的：我们设计组件架构图目的就是要决定应该让哪些组件稳定，让哪些组件不稳定。
**稳定抽象原则**
一个组件的抽象化程度应该与其稳定性保持一致。
在一个软件系统中，总有些部分是不应该经常变更的。这些部分通常用于表现该系统的高阶架构设计以及一些策略相关的高阶决策。
**稳定抽象原则简介**：该原则要求稳定的组件同时应该是抽象的，这样他的稳定性就不会影响到扩展性。另一方面，该原则也要求一个不稳定的组件应该包含具体的代码实现，这样它的不稳定性就可以通过具体的代码轻易修改。
**衡量抽象化程度： **抽象化程度 = 组件中抽象类和接口的数量/组件中类的数量
主序列
