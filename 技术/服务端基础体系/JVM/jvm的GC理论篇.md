谈到Java中内存回收，本地方法栈，虚拟机栈，程序计数器区域，是随着线程而生灭，每个栈帧的内存大小是在类结构确定下来后就确认的，着线程的结束，这些内存也将会被回收。运行过程中，创建多少个对象，创建哪些对象是动态的，不同的代码分支是不同的，我们垃圾回收期通常也是关注这部分代码怎么回收。

### 对象已死
垃圾回收器第一件事，就是挑选出已死对象，然后进行回收。
#### 引用计数算法
在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器就减一；任何时刻计数器为零的对象就是不可能再被使用。
引用计数算法占用了一些额外的内存空间来进行计数，原理简单，判定效率也比较高。但是目前主流的Java虚拟机都没有采用该算法。主要原因是，这个看似简单的算法有很多例外需要考虑，例如循环依赖。
#### 可达性分析算法
目前主流的商用程序语言的内存管理子系统都是通过可达性分析来判定对象的死活。这个算法的基本思路就是通过一系列的“GCRoots”的根对象作为起始节点集，从这些节点开始，根据引用关系想下搜索，搜索路称为“引用链”。如果对象到“GC Roots”没有任何引用链，或者用图论的话就是从“GC Roots”到对象不可达时，则证明此对象是不可能再被使用的。
GC Roots的对象包含以下几种：
* 虚拟机栈中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
* 本地方法栈中JNI（Native）引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象，譬如字符串常量池里的引用。
* Java虚拟机内部的引用，例如基本数据类型对应的Class对象，一些常驻异常对象（例如NullPointException,OutOfMemoryError）等，还有系统类加载器。
* 被同步锁（synchronized关键字）持有的对象

除了固定的GC Root集合，还可以有其它对象“临时性”加入，例如分代模型中，新生代的回收，老年的集合会加入到新生代中。

#### 再谈引用
无论通过引用计数器还是可达性分析，判断对象死活都和“引用”脱不了联系。Java中的reference类型通常代表着一块内存的起始地址，在这种定义下一个对象有两种状态，被引用和未被引用，对于描述一些“食之无味，弃之可惜”的对象就显得无能为力。在JDK1.2版本之后Java对引用进行了扩充。   
* 强引用 程序中正常的引用，引用关系存在，收集器就不会对对象进行回收
* 软引用 在发生内存溢出之前，会对这些对象列进回收范围之中，进行二次回收。
* 弱引用 每次垃圾回收，都会触发对象回收
* 虚引用 一个对象是否有虚引用的存在，完全不会对其生命时间造成影响。

#### 生存还是死亡
对象在进行可达性分析后发现没有与GCRoots相连接的引用链那么他将会第一次被标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。如果有则把对象放到一个名为F-Queue的队列中，并稍后有一个低调度优先级的线程去执行。如果在在finalize()中重新与引用链中对象关联，那么对象将会被拯救。如果finalize是官方不建议使用的方法。
```
finalize()是在java.lang.Object里定义的，也就是说每一个对象都有这么个方法。这个方法在gc启动，该对象被回收的时候被调用。其实gc可以回收大部分的对象（凡是new出来的对象，gc都能搞定，一般情况下我们又不会用new以外的方式去创建对象），所以一般是不需要程序员去实现finalize的。 
特殊情况下，需要程序员实现finalize，当对象被回收的时候释放一些资源，比如：一个socket链接，在对象初始化时创建，整个生命周期内有效，那么就需要实现finalize，关闭这个链接。 
```
#### 回收方法区
方法区相对于堆区，“性价比”比较低，《Java虚拟机规范》中提到可以不要在虚拟机方法区实现垃圾收集。方法区垃圾收集主要两部分废弃的常量和不再使用的类型。废弃的常量换句话说没有任何对象引用常量池中的常量。而判定一个类型是否属于不再使用的类型，条件比较苛刻，需要满足以下几个条件：
* 该类的所有实例都已经被回收，不存在该类及其派生子类的实例。
* 加载该类的类加载器已经被回收。该条件很难达成，除非可替换类加载器的场景。
* 该类对应的java.lang.Class对象没有任何地方被引用。没有通过反射访问该类方法。

在大量使用反射、动态代理、CGlib等自字节码框架，动态生成JSP及OSGI这类频繁自定义类加载场景，通常需要Java虚拟机具备类型卸载的能力。

### 垃圾收集算法

#### 分代收集的理论
当前商业虚拟机大多数都遵循了“分代收集”的理论进行设计，分代收集名为理论。建立在两个分代假说之上：
* 1）弱分代假说：绝大多数对象都是朝生夕灭
* 2）强分代假说：熬过越多次垃圾收集过程对象就越难消亡  
  
这两个分代假说奠定了常用垃圾收集器的一致设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄分配到不同区域存储。在Java堆划分出不同区域以后，垃圾收集器可以一次性只回收一部分或者一个区域的。因而有了“Minor GC”,"Major GC","Full GC"这样的回收类型划分；也才能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法--因而发展出了“标记-复制算法”，“标记-清除算法”，“标记-整理算法”等针对性的垃圾算法。  

分代收集实现中，不同代有各自的收集算法，且不同代的对象不是孤立的存在相互引用问题，例如在进行Minor GC时，GC Root需要添加老年代对象。如果遍历整个老年代，会带来比较多的性能负担，为了解决该问题，提出了第三条经验法则：
* 3）跨代引用假说：跨代引用相对于同代引用来说仅占极少数  
  
有了这条理论，我们不在为了跨代引用去扫描整个老年代，引入一个“记忆集”（Remembered Set）的概念，把老年代划分若干小块，标示出哪一块存在跨代引用。当发生Minor GC时，只需要把标记出的块内对象加入到GC Roots进行扫描。  

几个概念：新生代收集（Minor GC/Young GC），老年代收集（Major GC/Old GC）,混合收集（Mixed GC）,整堆收集（Full GC）

#### 标记清除
标记清除主要有两个缺点：第一个是执行效率不稳定，如果Java堆中包含大量对象，而且大部分是需要被回收，那么必须进行大量标记和清除动作，导致标记和清除两个过程的执行效率都随着对象数量增长而降低；第二个是内存空间的碎片话问题，标记、清除之后会产生大量不连续内存碎片，空间碎片太多可能会导致以后程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

#### 标记复制
将内存按照容量划分为大小相等的两块，每次只使用其中一块。当这一块内存使用完了，就将还存活的对象复制到另外一块上。再把已使用过的内存空间一次清理掉。如果内存中大多数对象是存活的，会产生大量内存间复制开销。如果是大多数对象可回收的，那么只需复制少量的存活对象，且不会产生空间碎片。代价是可用内存缩小到一半。

#### 标记整理
把标记后的存活对象，都移动到内存空间的一端，然后直接清理掉边界以外的内存。缺点比较明显，移动存活对象并更新所有引用这些对象的地方会是一种极为负重的操作。标记整理带来的停顿时间更长，但是整体吞吐量会优（GC次数更少）。HotSpot虚拟机中关注吞吐量的Parallel Scavenge收集器采用的是标记整理，关注延迟的Cms是采用的标记清除。实际上CMS的做法是一种“和稀泥式”，正常采用标记清除，当内存空间碎片化程度已经影响到对象分配时，再采用标记-整理收集一次。

### HotSpot的算法实现细节

#### 根节点枚举
在可达性算法中，GC Root本节点本身目标明确的，但是查找过程要做到高效，并非一件非常容易的事情。现在Java应用光是方法区可能就有几百兆，上千兆。里面的类、常量数量繁多，要是逐个查找需要耗费不少时间。  

目前所有收集器在根节点枚举这一步，都是必须暂停用户线程的。与之前提到的整理内存碎片想通，必须“stop the world”的困扰。现在可达性分析算法最耗时的操作是查找引用链过程，已经可以做到与用户线程并发了。根节点枚举始终还是必须一个能保障一致性快照（某一个时间点）中才得以进行。  

解决查找扫描问题，HotSpot的解决方案里，使用一组称为OopMap的数据结构来达到这个目的。一旦类加载动作完成，HotSpot就会把对象内什么偏移量上是什么类型计算出来。在即时编译过程中，也会在特定位置记录下栈和寄存器里哪些位置是引用。也就是说通过OopMap可以在方法区，以及调用栈找到相应的对象引用。

#### 安全点
在OopMap的协助下，HotSpot可以迅速准确的完成GC Roots枚举，但是可以引起OopMap变化的指令非常多。如果为每一个都生成相应的OopMap那么需要大量额外存储，实际上HotSpot的实现是在特定的位置记录这些信息，这特殊的位置被称为安全点。安全点的选择既不能太少以至于让收集器等待时间过长，也不能太过频繁以至于过分增大运行时的内存负荷。选择为“长时间执行指令”，例如：方法调用、循环跳转、异常跳转等。    

还需要考虑一点，用户线程执行到安全点然后中断的方式。一是抢占式，垃圾收集器中断所有用户线程，如果发现用户线程不在安全点，恢复用户线程，让他一会再中断。现在几乎所有虚拟机都没有采用抢占式。二是主动式，主动式中断思想是线程在执行在安全点时，查询一个标志，是否需要中断。查询操作比较频繁需要足够高效，HotSpot采用内存保护陷阱方式，`test   %eax,0x160100` ,如果需要中断用户线程，虚拟机把0x160100设置为不可读，那么test指令会产生一个自陷异常信号，实现中断。

#### 安全区域
安全点设计，如果当前用户线程处于sleep或者blocked状态，此时候用户线程不能响应虚拟机的中断请求。这种情况引入安全区域。安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），如果完成了，那线程就当作没事发生过，继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止。  

个人理解为，当被挂起的线程都处于安全区域，当继续执行时需要判断是否处在暂停用户线程状态。

>深入Java虚拟机并没有对于根节点枚举和安全点给出足够的解释，可以具体参考下面这两个文章。

>[根节点枚举](https://www.iteye.com/blog/dsxwjhf-2201685)  
[根节点枚举和安全点详细](https://www.iteye.com/blog/rednaxelafx-1044951)

#### 记忆表与卡片集
Remembered Set是在实现部分垃圾收集（partial GC）时用于记录从非收集部分指向收集部分的指针的集合的抽象数据结构。

* 分代式GC是一种部分垃圾收集的实现方式。当分两代时，通常把这两代叫做young gen和old gen；通常能单独收集的只是young gen。此时remembered set记录的就是从old gen指向young gen的跨代指针。

* Regional collector也是一种部分垃圾收集的实现方式。此时remembered set就要记录跨region的指针。

如果记录非收集区域的所有的对象引用，那么空间成本和维护成本都会非常高。而实际上收集器只需要判断出一块内存区域是否有跨代引用即可。可以用更为粗犷的力度来实现。    

关于粒度，一般隐式假设
* Remembered Set：对象粒度（remembered set里存有old generation的对象的指针）；
* Card Table：card粒度（通常是2的幂字节大小的内存区域，例如HotSpot用512字节），里面可能包含多个对象。

其实无论是remembered set还是card table，记录精度都有很大的选择余地：
* 字粒度：每个记录精确到一个机器字（word）。该字包含有跨代指针。
* 对象粒度：每个记录精确到一个对象。该对象里有字段含有跨代指针。
* card粒度：每个记录精确到一大块内存区域。该区域内有对象含有跨代指针。
* （还有其它可能性，任君想像）
  

通常来说，卡片集（Card Table）是一种粗粒度记录的记忆表的实现（虽然理论概念上card 大小可以随意）。以HotSpot的实现为例，`CARD_TABLE [this address >> 9] = 0`，定义了一个数组，地址右移9位，可以理解位512字节位一个区域，也就是卡片粒度。只要这块区域内有一个跨代引用那么`CARD_TABLE [this address >> 9] = 1`，称为变脏（Dirty），垃圾收集发生时，只要筛选出卡表中变脏的元素，然后得出卡内内存块有哪些跨代指针，把他们加入GC Root中一起扫描。

>
[RX大神关于Remembered Set的回复](https://hllvm-group.iteye.com/group/topic/21468)

#### 写屏障
卡表元素该如何维护呢，是谁来负责将卡表元素变脏，何时变脏。何时变脏比较好理解，发生跨代引用的瞬间，也就是跨代对象赋值瞬间。但是那一刻如何去更新卡表呢？如果是解释执行，相对好处理，虚拟机负责字节码指令执行，会比较容易介入。但是在编译执行场景，编译后的代码已经是纯粹的机器指令流，那么需要找到一个机器码，把维护卡表动作放在赋值操作中。HotSpot是通过写屏障来实现。（注意写屏障概念与读屏障、内存屏障概念不要混淆，他们是不同的概念，为了解决不同的问题）。写屏障可以看作在虚拟机层面，“引用类型字段赋值”动作的切面，在引用对象赋值时，会产生一个环形（around）通知(类似aop)，供程序执行额外的动作。那么虚拟机就可以通过写屏障来实现，更新卡表的操作。  

如果在每次引用操作都去更新卡表，那么会有一个“伪共享”引起的性能问题，一个卡表标记（0or1)占用一个字节，一个缓存行是64字节，那么一个缓存行可以存储64个卡表标记，也就是说了64*512=32kb内的一次引用都会更新同一个缓存行。如果多线程下，那么会代理性能降低。一个解决方案时，在更新卡表前，先判断卡表是否已经被标记，判断也是有一次读操作的成本。这个需要开发者自己去权衡，HotSpot虚拟机有一个的参数-XX：+UseCondCardMark，用来决定是否开启卡表更新的条件判断。  

#### 并发的可达性分析
在可达性分析中，GCRoot相比整个堆来说，是极少数的。从GCRoot再继续往下遍历对象图，停顿过程与堆的大小成正比例关系，目前并行垃圾收集器，这个过程一般是与用户线程并发执行的。那么我们怎么去解决，并行过程中引用的变化。引入三色标记来进行分析：
* 白色：表示对象尚未被垃圾收集访问过，显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若分析结束阶段，仍是白色的对象，表示对象不可达
* 黑色：表示对象已经被垃圾收集器访问过，且这个对象所有引用都已经扫描过。
* 灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。

在可达性分析中，可以理解为已灰色为波峰的波纹，从黑向白推进的过程。那么在用户线程与垃圾收集并发工作中会有什么样的问题呢？可能会有两种后果：一（浮动垃圾）：是把本应消亡的对象标记为存活，这样可以容忍，下次垃圾收集清理掉就可以。二（漏标）：是把本应存活的对象标记为消亡，这样就会产生比较严重后果。在什么情况下会产生漏标。可以理解为，在并发执行过程中，白色对象变为黑色对象。需要满足以下任意一个条件：
* 赋值器新增了一条黑色对象到白色对象的新引用
* 赋值器删除了全部灰色对象到该白色对象的直接或者间接引用

要解决并发扫描过程中，对象消失问题，只需要破坏这两个条件的任意一个即可。由此分别产生了两种解决方案：增量更新（Incremental Update）和原始快照（Snapshot At The Beginning,SATB）  

增量更新要破坏第一个条件，当黑色对象插入新的指向白色对象引入关系时，把新的插入引用记录下来，等扫描结束，将记录过引用关系中的黑色对象为根，重新扫描。思考：灰色扫描时，应该是保留记录下来的引用进行扫描，所以叫原始快照。  

原始快照要破坏第二个条件，当灰色对象要删除白色对象的引用时，将这个要删除的引用记录下来，在并发扫描结束之后，再将记录过引用关系的灰色对象为根，重新扫描。
CMS采用增量更新，G1、Shenandoah则是用原始快照来实现。
> 对于这个是有一些疑惑的，记住即可。我们在学习具体的回收算法时，再进行具体学习，进一步理解

