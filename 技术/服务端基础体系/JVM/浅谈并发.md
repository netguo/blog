### 概述
现在计算机硬件，处理器的处理速度远远高于内存/磁盘/网络，避免处理器大量空闲时间处于闲置等待状态，充分压榨处理器资源，多任务执行是一个重要手段。充分提高并发环境下处理器的处理能力，硬件、操作系统、编程语言都做过大量的优化处理。
### 硬件效率和一致性
现在处理器在计算时，需要从内存中读取数据，CPU处理速度远远高于内存读取速度，为了充分利用处理器，每个处理器有自己的L1、L2、L3缓存。这样也为处理器并发处理带来新的复杂度，缓存一致性。为了保证缓存一致性，处理器读取缓存时需要遵循缓存一致性协议，目前主流缓存一致性协议MESI、MSI等。处理器优化执行效率手段还有指令重组，并保证结果执行正确性。Java编译中也有这样的手段，指令重排序。
### Java内存模型
java虚拟机规范定义一种内存模型(JMM)来屏蔽硬件和操作系统内存访问差异，以实现让Java程序在各种平台下都能达到一致性内存访问效果。Java内存模型规定了所有变量都存储在主内存中，每个线程有自己的工作内存，存储了变量的副本。线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。
该处内存模型和java内存区域中的java堆、栈、方法区部署同一个层次。
#### 主内存和工作内存间的交互
 java内存模型定义了8种操作来完成主内存和工作内存的交互操作，lock(作用于主内存的变量、把一个变量标识为线程独占的状态)、unlock、read、load、use、assign、store、write。虚拟机的实现保证每一个操作都是原子的、不可再分的。后来虚拟团队，简化为read、write、lock、unlock。
#### volatile
volatile修饰的变量具备两个特性：可见性、禁止指令重排序。
可见性
volatile修饰的变量在不同线程工作内存中会存在不一致情况，每次使用前保证从主内存中重新刷新，保证可见性。
不过volatile不能保证操作的原子性，因为java的运算符操作并非原子操作，例如a++会翻译成多个指令，部分场景下如(!success)，比加锁更高效。
禁止指令重排序：通过操作系统“lock addl$0x0，(%esp)“语义实现。
volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢上一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。不过即便如此，大多数场景下volatile的总开销仍然要比锁来得更低。
#### 原子性、可见性、有序性
原子性
原子性指的是某个线程在执行操作时，要么执行完成，要么没有执行。
内存模型保证的read、load、assign、use、store、write的原子性，大致可以认为基础数据类型读写都是原子性的。如果需要一个更大范围的原子性保证，需要lock和unlock操作，也提供了更高层次的字节码指令monitorenter、monitorexit。
可见性
可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看到修改的值。除了volatile，java还有两个关键词能够实现可见性，synchronized和final。被final修饰的字段，构造器没有把this引用传递出去(this引用逃逸，其他线程可能看到this引用初始化一半的对象)
有序性
java语义单线程内是有序的，其他线程观察本线程是无序的。volatile可以禁止指令重排序，synchronized保证不同线程的有序性。
#### Happens-Before
happens-before原则指的是java内存模型中定义的两项操作之间的偏序关系，也就是说这些规则是天然有序的，不需要其它关键字保障其有序性。
程序的顺序、管程锁定、volatile变量、线程启动、线程启动、线程终止、线程中断、对象终结、传递性。
### Java线程
#### 线程实现
线程的实方式有三种：使用内核线程1:1的实现，通过用户线程1:N的实现，通过用户线程和轻量级进程N:M的实现。
内核线程1:1
使用内核线程实现的方式也被称为1：1实现。内核线程（Kernel-Level Thread，KLT）就是直接由操作系统内核（Kernel，下称内核）支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。
用户线程1:N
用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在及如何实现的。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。
用户线程和轻量级进程N:M
这种混合实现下，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射。

#### Java线程的实现
主流商用Java虚拟机的线程模型普遍都被替换为基于操作系统原生线程模型来实现，即采用1：1的线程模型。
java线程调度，java系统使用抢占式调度，Java语言一共设置了10个级别的线程优先级（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY）。在两个线程同时处于Ready状态时，优先级越高的线程越容易被系统选择执行。不过，线程优先级并不是一项稳定的调节手段，很显然因为主流虚拟机上的Java线程是被映射到系统的原生线程上来实现的，所以线程调度最终还是由操作系统说了算。第一点，java优先级与不同操作系统优先级不能建立完全映射关系，第二点操作系统对优先级会有优化。

#### 协程
目前java主流形态还是1:1通过内核线程来实现线程调度，线程调度需要用户态和内核态切换，在目前web服务中，并发要求高，系统中线程多，性能比较难满足。协程就是1:N用户线程形态，用户态需要实现线程调度、上下文切换等，线程切换成本低，不过需要用户态系统实现线程调度成本较高。
java的实现：纤程，Project Loom是OpenJDK的一个子项目，还在进行中。
纤程是有栈协程的一种实现方式，纤程并发的代码会被分为两部分——执行过程（Continuation）和调度器（Scheduler）。执行过程主要用于维护执行现场，保护、恢复上下文状态，而调度器则负责编排所有要执行的代码的顺序。

### 线程安全和锁优化
#### 线程安全
当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。
##### java中线程安全
线程安全由强到弱，可以将Java语言中各种操作共享的数据分为以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。
不可变
不可变（Immutable）的对象一定是线程安全的，java提供了final关键词。如果是对象，需要对象自身内部保证不可变性。
绝对线程安全
一个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”可能需要付出非常高昂的，甚至不切实际的代价。在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。例如两个线程分别循环调用Vector的get()和add()方法。
相对线程安全
相对线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单次的操作是线程安全的。在Java语言中，大部分声称线程安全的类都属于这种类型，例如Vector、HashTable、Collections的synchronizedCollection()方法。
线程兼容
线程兼容是指对象本身并非线程安全的，但是可以通过在外部加锁的方式使其变成线程安全的。
线程对立
线程对立是指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码。例如：Thread类的suspend()和resume()方法。
##### 线程安全实现
互斥同步
java中提供了一些关键字，如synchronized、ReentrantLock、ReentrantReadWriteLock等，用于实现互斥同步。synchronized关键字在经过编译后，会在同步块的前后分别形成monitorenter和monitorexit两个字节码指令。synchronized是可重入的。从JDK5开始JUC包中提供了Lock接口，Lock的实现类有ReentrantLock、ReentrantReadWriteLock等。ReentrantLock与synchronized相比增加了一些高级功能，主要有以下三项：等待可中断、可实现公平锁及锁可以绑定多个条件。
非阻塞同步
基于冲突检测的乐观并发策略，通俗地说就是不管风险，先进行操作，如果没有其他线程争用共享数据，那操作就直接成功了；如果共享的数据的确被争用，产生了冲突，那再进行其他的补偿措施，最常用的补偿措施是不断地重试，直到出现没有竞争的共享数据为止。乐观并发策略也依赖硬件指令的发展，因为操作和冲突检测需要是原子性的。常用的CAS是通过cmpxchg指令实现的。
CAS会带来常见的ABA问题，为了解决JUC提供了一个带版本号的AtomicStampedReference类。通过控制版本保证CAS的正确性，不过大多数情况ABA问题不会影响程序并发的正确性。
无同步方案
如果线程中不涉及共享数据，就不需要任何同步手段去保证正确性。简单介绍两类。
可重入代码：是指可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误，也不会对结果有所影响。可重入代码有一些共同的特征，例如，不依赖全局变量、存储在堆上的数据和公用的系统资源，用到的状态量都由参数中传入，不调用非可重入的方法等。
线程本地存储 (Thread Local Storage)

#### 锁优化
高效并发是JDK5升级到JDK6后的一项重要改进措施。虚拟机开发团队花费了大量的资源去实现各种锁优化，例如：自适应锁、锁消除、锁粗化、轻量级锁和偏向锁等。
##### 自旋锁与自适应锁
互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因为挂起和恢复线程都需要转入到内核态中。许多应用锁定状态只会持续很短一段时间，为了这段时间去挂起和恢复线程并不值得。
，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，所以如果锁被占用的时间很短，自旋等待的效果就会非常好，反之如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源。因此自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。
##### 锁消除
锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。
##### 锁粗化
如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。例如循环体，可能会放在循环体之外。
##### 轻量级锁和偏向锁
轻量级锁和偏向锁的，设计的初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。
具体参考：《线程安全和锁优化》