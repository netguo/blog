### 一、事务的定义
事务是数据库的基本工作单元，它以all-or-nothing的方式执行，让数据库从一个一致的状态转移到另一个一致的状态。即使系统发生故障，未执行完成的事务依然可以正确恢复，而事务之间可以在不同程度上进行隔离，以保证数据的正确性。

### 二、事务的一些概念
##### 事务状态
* 开启事务：Start Transaction
* 事务结束：End Transaction
* 提交事务：Commit Transaction
* 回滚事务：Rollback Transaction
* 创建保存点：SAVAPOINT 
* 删除保存点： RELEASE SAVAPOINT
* 回滚到保存点： ROLLBACK TO SAVAPOINT
* 设置事务隔离级别：SET Transaction

##### 事务分类
* 扁平事务
  事务类型中最简单的一种，但在实际生产环境中，这可能是使用最频繁是事务。在扁平事务中，所有操作都处于同一层次，其由BEGIN WORK开始，由COMMIT WORK或ROLLBACK WORK结束，其间的操作都是原子的，要么都执行，要么都回滚。
* 带保存点的扁平事务
  扁平事务的主要限制是不能提交或者回滚事务的某一部门，或分几个步骤提交。带保存点的事务解决了这个问题，允许事务执行过程中回滚到同一事务中的较早状态。保存点用来通知系统应该记住事务当前的状态，以便当之后发生错误时，事务能回到保存点当时的状态。
* 链事务
  在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐私的传给下一个要开始的事务。提交事务操作喝开始下一个事务操作将合并成为一个原子操作。下一个事务将会看到上一个事务的结果。链事务区别与保存点事务区别是，保存点事务可以回滚到任意保存点，链事务可以只能回滚到最近一个保存点。
* 嵌套事务
  嵌套事务是一个层级结构框架，moss定义如下：
  a. 嵌套事务是由若干事务组成的一棵树，子树既可以是嵌套事务，也可以是扁平事务。
  b. 处在叶节点的事务是扁平事务。但是每个子事务从跟到叶节点的距离是可以不同的。
  c. 位于根节点的事务称为顶层事务，其他事务称为子事务。事务的前驱称为父事务，事务的下一层称为儿子事务。
  d. 子事务既可以提交也可以回滚。但是它的提交操作并不马上生效，除非其父事务已经提交。因此可以推论出，任何子事务都在顶层事务提交后才真正的提交。
  e. 树中的任意一个事务的回滚会引起它的所有子事务一同回滚，故子事务仅保留a,c,i特性，不具有d的特性。
  嵌套事务，父事务可选择把锁传递给子事务，子事务也可以自己持有锁，因此可以做的锁隔离。其次嵌套事务可以支持并行支持各个子事务。
  其中采用保存点方式可以模拟嵌套事务，不过对于以上两点是实现不了的，保存点事务锁共享，做不到并行执行。
* 分布式事务
  分布式事务通常是一个在分布式环境下允许的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。

对于InnoDB存储引擎来说，其支持扁平事务，带有保存点的事务，链事务，分布式事务。对于嵌套事务，其并不原生支持。  

##### 事务的四大特性
原子性，一致性，隔离性，持久性
* 原子性(A)：事务是最小单位，不可再分，原子性保证一个事务中的所有操作要么全部执行，要么全部不执行（执行中出错则全部回滚）。
* 一致性(C)：事务要求所有的DML语句操作的时候，必须保证同时成功或者同时失败。事务将使数据库从一个有效的状态转换到另一个有效的状态，满足定义的所有规则，包括约束，级联，触发器等
* 隔离性(I)：事务A和事务B之间具有隔离性
* 持久性(D)：是事务的保证，事务终结的标志(内存的数据持久到硬盘文件中)，已提交的事务，将会对数据库产生永久的影响


### 三、事务的隔离性
隔离性，这个我们比较好理解，事务隔离类似并发问题，多个事务操作同一个数据时，需要隔离。

##### 事务带来并发问题
我们先看多事务并发操作可能带来哪些问题：  
* 更新丢失（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题。
* 脏读（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务完成并提交前， 这条记录的数据就处于不一致状态； 这时， 另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做"脏读"。可以理解为，一个事务读取了另一个事务未提交的数据。
* 不可重复读（Non-Repeatable Reads）：一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读” 。
* 幻读 （Phantom Reads）： 一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读” 。

不可重复读与幻读：不可重复读的重点是修改：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改），幻读的重点在于新增或者删除：在同一事务中，同样的条件,第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）
可以看出上述问题，对于并发的控制要求是逐渐提升的，1. 不关心其它事务 2. 可以关心到其它事务未提交内容 3. 必须关心到其它事务已经提交内容 4. 事务执行过程中，事务中的数据不会发生变化。 5. 事务查询条件中数据没有新增或者删除。

##### 事务的隔离性
大部分数据库系统并没有实现真正的隔离性。或许最初数据库的实现者没有弄清楚这些问题，现在弄清楚了，但是数据库的实现着在正确性与性能之间做了妥协。ISO和ANIS SQL标准制定了四种隔离级别。

* READ UNCOMMITTED
  所有事务都可以看到其他未提交事务的执行结果，可引起脏读
* READ COMMITTED
  一个事务只能看见已经提交事务所做的改变，可以解决脏读，不能解决不可重复读。
* REPEATABLE READ 
  确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。可以解决不可重复读。不过不能解决不来幻读，如果有新的数据行插入或者删除，会引起幻读问题。innodb的实现的隔离级别。
* SERIALIZABLE
  事务隔离的最高级别，通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。


### 四、事务的实现
原子性、一致性、持久性通过数据库的redo log和undo log来完成。redo log称为重做日志，用来保证事务的原子性和持久性。undo log用来保证事务的一致性。有的dba获取认为undo是redo的过程，其实不然。redo喝undo的作用都可以视为是一种恢复操作，redo恢复提交事务修改的页操作，undo回滚行记录到某个特点版本。redo通常是物理日志，记录的是页的物理修改操作。undo是逻辑日志，根据每行记录进行记录。

##### redo
重做日志用来实现事务的持久性。即事务中的D特性。其由两部分组成：一是内存中重做日志缓冲，其是易失的；二是重做日志文件，其是持久的。
InnoDB是事务的存储引擎，其通过Force Log at Commit机制实现事务的持久性，即当事务commit时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的commit操作完成，才算完成。这里的日志指重做日志，在InnoDB存储引擎中，由两部分组成，即redo log和undo log。redo log用来保证事务的持久性，undo log用来帮助事务回滚及mvcc的功能。redo log基本上都是顺序写的，在数据库运行时不需要对redo log的文件进行读取操作，而undo log是需要进行随机读取的。
重做日志是先写入文件系统缓存，再写入磁盘的。写入磁盘必须进行一次fsync操作，fsync性能有磁盘性能决定。为了提高重做日志的性能，可以等待一个时间周期后再从缓存写入磁盘。Innodb通过innodb_flush_log_at_trx_commit来控制。默认为1，事务每一次提交都必须调用一次fsync。0标识把管理权交给主线程，1s一个周期去写入一次。标识2，仅仅写入缓存，不执行fsync写入磁盘。可以看出，0,2在mysql宕机时会有事务丢失。
在批量操作大量数据，保证宕机不丢失，可以采用默认，批次执行commit，这样减少写磁盘。

##### binlog
重做日志是在InnoDB存储层产生，而二进制日志是在MySQL数据库层产生的。并且二进制日志不仅仅针对InnoDB存储引擎。mysql数据库上层，针对的是逻辑日志，是sql语句，重做日志（redo）是物理日志，针对的是每个页的修改。
binlog只在事务提交完成后进行一次写入，redo在事务进行中不断地写入，且写入是并发操作的，因此文件中记录的顺序并非事务开始顺序。
biglog    |T1|T2|T3|T4|T5|
redo  |T1|T2|T1*|T3|T2*|...，T1*表示T1的开始事务。

##### undo
undo 保证的数据的回滚，与mvcc锁功能。在mysql中undo日志有一个特定的表空间进行存储。undo跟redo相似，是存储的逻辑日志，针对物理页的修改。回滚操作中，undo并不是回滚到原始的物理页状态，只是对redo日志做反向操作。insert的redo做delete操作，update操作做update反操作。
mvcc功能单独找时间整理。

##### 锁
事务的隔离性是通过mvcc和锁实现的。单独找时间学习。