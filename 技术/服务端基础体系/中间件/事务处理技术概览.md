事务处理几乎在每一个信息系统都会涉及，为了保证系统中所有的数据都符合期望，且相互关联的数据之间不会产生矛盾，即数据状态的**一致性**。按照数据库的经典理论，要达成这个目标，需要三方面保证：原子性、隔离性、持久性。 

**内部一致性**  

当一个服务只使用一个数据源时，通过A、I、D来获得一致性。  

**外部一致性**  

当一个服务使用多个数据源，甚至多个不同服务同时涉及不同数据源时，问题就变得困难多了，外部一致性问题通常很难使用A、I、D来解决，因为这样会付出很大的代价，为此我们要转变观念，将一致性从“是或否”的二元属性转变为可以按不同强度分开讨论的多元属性，在确保代价可承受的前提下获得强度尽可能高的一致性保障，也正因如此，事务处理才从一个具体操作上的“编程问题”上升成一个需要全局权衡的“架构问题”。
事务分类：扁平事务、带保持点的扁平事务、链事务、嵌套事务、分布式事务
### 本地事务
本地事务是一种最基础的事务解决方案，只适用于单个服务使用单个数据源的场景。
#### 实现原子性和持久性
实现原子性和持久性的最大困难是“写入磁盘”这个操作并不是原子的，不仅有“写入”与“未写入”状态，还客观存在着“正在写”的中间状态。由于写入中间状态与崩溃都不可能消除，所以如果不做额外保障措施的话，将内存中的数据写入磁盘，并不能保证原子性与持久性。由于写入存在中间状态，所以可能出现以下情景：

- 未提交事务，写入前崩溃：事务未提交，数据已经写入磁盘
- 已提交事务，写入后崩溃：事务以及提交，数据还未写入磁盘

**Commit Logging**
由于写入中间状态与崩溃都是无法避免的，为了保证原子性和持久性，只能在崩溃后采取恢复的补救措施。补救措施采用“提交日志”（Commit Logging）实现。

- 日志记录存储的是，修改数据需要的全部信息，包括修改什么数据、数据物理上位于哪个内存页和磁盘块中、从什么值改成什么值等等。
- 日志以顺序追加的文件写入形式，数据库在日志中看到事务成功提交的“提交记录”（Commit Record）后，对真正数据进行修改，修改后加入一条“结束记录”（End Record）表示事务已经完成持久化。
- 日志写入Commit Record表示整个事务成功了，即使真正修改数据时崩溃了，重启后根据日志信息恢复现场进行数据恢复即可。
- 日志没有写入Commit Record就发生崩溃，整个事务就是失败的，将这部分日志记为回滚状态即可，整个事务像没有发生过。

Commit Logging存在一个巨大的先天缺陷：所有对数据的真实修改都必须发生在事务提交之后，即日志写入Commit Record之后。在此之前，即使磁盘I/O有足够空闲，即使某个事务修改的数据量非常庞大，占用了大量的内存缓冲区，无论何种理由，都决不允许在事务提交之前就修改磁盘上的数据，这一点对提升数据库的性能十分不利。
**Write-Ahead Logging**
针对Commit Logging的性能问题，提出了“提前写入日志”（Write-Ahead Logging）的日志改进方案，所谓“提前写入”，就是允许在事务提交之前写入变动数据的意思。
按照事务提交时点，将何时写入变动数据分为FORCE和STEAL两类情况：

- FORCE：当事务提交后，要求变动数据必须同时完成写入则称为FORCE，如果不强制变动数据必须写入完成则成为NO-FORCE。
- STEAL：在事务提交前，允许变动数据提前写入则称为STEAL，不允许则称为NO- STEAL。

Commit Logging允许NO-FORCE，但不允许STEAL，Write-Ahead Logging允许NO- FORCE，也允许STEAL，它给出的办法是增加另一种被称为Undo Log的日志类型。当变动数据写入磁盘前，必须先记录Undo Log，注明修改了哪个位置的数据、从什么值改成什么值等，以便在事务回滚或者崩溃恢复时根据Undo Log对提前写入的数据变动进行擦除。Undo Log现在一般被翻译为“回滚日志”，此前记录的用于崩溃恢复时重演数据变动的日志就相应被命名为Redo Log，一般翻译为“重做日志”。
崩溃时恢复三个阶段：

- 分析阶段：根据最后一个Checkpoint，找出没有End Record的事务，组成带恢复事务集合，这个集合至少包括事务表和脏页表。
- 重做阶段（Redo）:根据待恢复事务集合，来重演历史，数据写入磁盘，并在Commit Record中增加一条End Record。
- 回滚阶段（Undo）：经过重做阶段后，剩下的都是需要回滚的事务，被称为loser，也就是提前写入的undo日志，讲提前写入的日志回滚回去。
#### 实现隔离性
**锁实现**

- 读锁（S Lock），共享锁，多个事务可以对同一个数据添加多个读锁
- 写锁（X Lock），排他锁，如果数据有写锁，就只有持有写锁的事务才能对数据进行写入操作
- 范围锁（Range Lock），对某个范围直接加排他锁

**隔离级别**

| 隔离级别 | 特点 | 问题 |
| --- | --- | --- |
| 串行执行 | 串性化访问提供了最强的隔离性，每一次操作都会加锁、解锁，性能较差。 | 无 |
| 可重复读（Repeatable Read） | 对所有事务加读锁和写锁，持续到事务结束，但不再加范围锁。 | 幻读：两个相同范围查询得到不同的结果集 |
| 读已提交（Read Committed）| 对事务涉及数据加写锁持续到事务结束，但读锁查询完成后立马释放。 | 幻读，不可重复读：在同一事务中，对同一行数据的两次查询得到不同的结果。两次查询结果之间有变更。 |
| 读未提交（Read Uncommitted） | 只会对事务涉及的数据加写锁，且一直持续到事务结束，但完全不加读锁。 | 幻读，不可重复读，脏读：一个事务执行过程汇中读取到另一个事务未提交的数据。写锁禁止其它事务施加读锁，而不是禁止事务读取数据，如果事务T1读取数据前并不需要加读锁的话，就会导致T2未提交的数据也马上能被事务T1所读到。 |

### 全局事务  

**本节全局事务被限定为一种适用于单个服务使用多个数据源场景的事务解决方案。** 理论上真正全局事务并没有“单个服务”的约束，它本来就是DTP模型中概念，为了避免于后续介绍的放弃了ACID的弱一致事务处理方式混淆，**这里讨论一种分布式环境中仍追求强一致性的事务处理方案。**
#### 两阶段式提交
```
aTransaction.begin();
bTransaction.begin();
cTransaction.begin();
try{
  a.update();
  b.update();
  c.update();
}catch(Exception e){
  aTransaction.rollback();
  bTransaction.rollback();
  cTransaction.rollback();
}
```
按照如上代码，如果c.update()出问题，a、b事务已提交，此时a、b事务回滚已经无济于事。为了解决这个问题，XA事务提交拆分成两个阶段。

- 准备阶段：又叫做投票阶段，在这一阶段，协调者询问事务所有参与者是否准备好提交，参与者如果已经准备好提交则回复Prepared，否则回复Non-Prepared。对于数据库，而言对于重做日志是否写入Commit Record。这意味着在做完数据持久化后并不立刻释放隔离性，即仍持有锁。
- 提交阶段：又叫做执行阶段，协调者如果在上一阶段收到所有事务参与者回复的Prepared消息，则先在自己在本地持久化事务状态为Commit，然后向所有参与者发送Commit指令。让所有参与者立即执行提交操作；否则任意一个参与者回复了Non-Prepared消息，或任意一个参与者超时未回复时，协调者将在自己完成事务状态为Abort持久化后，向所有参与者发送Abort指令，让参与者立即执行回滚操作。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/8364057/1678432555911-dcea92ba-229e-4207-87c5-9ad12bf4b972.png#averageHue=%23f5f5f5&clientId=u1be8a893-1fd7-4&from=paste&height=284&id=ud7065a67&originHeight=789&originWidth=720&originalType=binary&ratio=2&rotation=0&showTitle=false&size=205929&status=done&style=none&taskId=uc02780f7-c9cf-48b4-8e12-a23013f188c&title=&width=259)
**二阶段提交缺点**

- 单点问题：如果宕机的是协调者，没有正常发送Commit或Rollback指令，那所有参与者都必须一直等待。
- 性能问题：整个过程需要两次远程服务调用，三次数据持久化，整个过程将持续到参与者集群中最慢的那一个处理操作结束为止。
- 一致性风险：当网络稳定性和宕机恢复能力的假设不成立时，仍可能出现一致性问题。
#### 三阶段式提交
为了缓解两段式提交协议的一部分缺陷，具体地说是单点问题和性能问题，后续又发展出三阶段式提交。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/8364057/1679042622045-499eec71-3d88-476b-96e6-021ac97d6268.png#averageHue=%23f8f8f8&clientId=ua71827c4-2093-4&from=paste&height=609&id=u11901dce&originHeight=1217&originWidth=869&originalType=binary&ratio=2&rotation=0&showTitle=false&size=257368&status=done&style=none&taskId=ucf3acc62-4443-4680-8afc-47e0bbdc349&title=&width=434.5)
三段式提交把原本两阶段式提交的准备阶段再细分为两个阶段，分别称为CanCommit、PreCommit，把提交阶段称为DoCommit阶段。
新增的CanCommit是一个询问阶段，即协调者让每个参与的数据库根据自身状态，评估该事务是否有可能顺利完成。一分为二的原因，该阶段资源消耗比较大，如果此时某一个参与者宣告无法完成提交，相当于大家都做了一轮无用功。这意味回滚风险变小。
在事务回滚场景中，三段式提交性能通常比两段式提交好很多，但在正常提交场景中，多了一次询问，性能比二阶段更差一些。
如果在PreCommit阶段之后发生了协调者宕机，即参与者没有等到DoCommit的消息的话，默认的操作策略将是提交事务而不是回滚事务或者持续等待，这就相当于避免了协调者单点问题的风险。
### 分布式事务
本节所说的分布式事务特指多个服务同时访问多个数据源而言的事务处理机制。2000年以前，人们曾经希望XA事务机制在分布式环境中也能良好应用，但这个美好的愿望已经本CAP理论彻底击碎了。
CAP定理，在一个分布式系统中，以下三个特性最多只能满足其中两个

- 一致性：数据在任何分布式节点中所看到的都是符合预期的。
- 可用性：代表系统不间断提供服务的能力。两个密切相关的指标：可靠性和可维护性。可靠性使用平均无故障时间来度量（MTBF）；可维护性使用平均可修复时间来度量（MTTR）。即可用性A=MTBF/(MTBF+MTTR)，通常5个9，4个9，3个9等。
- 分区容忍性：代表分布式环境中部分节点因网络原因而彼此失联后，系统仍能提供服务的能力。

舍弃C、A、P所带来的不同影响

- 放弃分区容忍性：意味着我们将假设节点之间的通信是永远可靠的。这个在分布式系统中是必定不成立的。
- 放弃可用性：这意味需要保持一致性，意味着一旦网络发生分区，节点之间的信息同步时间可以无限延长。可以通过2PC/3PC等手段。在现实中放弃可用性的情况一般出现在对数据质量要求很高的场合，除了分布式数据事务外，著名的HBase也属于CP系统。
- 放弃一致性：意味一旦发生分区，节点之间所提供的数据可能不一致。目前大多数NoSQL库和支持分布式缓存的框架都是AP系统。

在分布式环境中，选择放弃一致性的AP系统是分布式系统的主流选择。但无论如何，我们建设系统时，终究还是要确保操作结果最终交付是正确的。这意味允许数据在中间出错，但应该在输出时被修正过来，这样的一致性被称为“弱一致性”，又被称为“最终一致性”。本节讨论的分布式事务，追求获得的是“最终一致性”。
#### 可靠事件队列
最终一致性的概念是由eBay的系统架构师在2008年提出，该论文中总结了一种独立于ACID获得强一致外，使用BASE来达成一致性目的的途径。BASE分别是基本可用性、柔性事务和最终一致性的缩写。
示例：某电商账户购买某商品：用户账号扣款，库存商品出库，商家账户收款。
1）对用户账号扣款，库存商品出库，商家账户收款，这三个操作有一个出错概率的先验评估，根据出错概率的大小来安排操作顺序。有些复杂的也会采用动态排序。如这里的用户账户出错概率最大，顺序是用户账号扣款->库存商品出库->商家账户收款。
2）用户账号扣款，成功。
3）通过消息队列通知仓库服务出库，商家账号收款，并在本地存储一个消息状态表，分布式事务ID、事务状态（“进行中”、“已完成”）。
4）如果仓库出库成功、商家账户收款成功，通过消息发送给账户服务，消息状态表更改为已完成。
5）账号服务循环定期检查仓库出库、商家收款的消息状态表，如果还在进行中则重新发送消息，至到成功。因为此时可能会有消息丢失，例如商家收款成功，但是通知账户是消息丢失，账户会重新发送消息，因此商户收款和仓库扣减库存必须具备幂等性。
6）此处重发消息是保证必须成功的，否则一直重发。计算机领域专业称呼“最大努力交付”，在该事件队列场景也被称为“最大努力一次提交”。
7）如果一直重试不成功，可能需要人工介入。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/8364057/1679120293369-eb756d74-7ada-4d23-a508-d6ed410ae7be.png#averageHue=%23f9f9f9&clientId=ua71827c4-2093-4&from=paste&height=319&id=ud5785972&originHeight=1220&originWidth=1556&originalType=binary&ratio=2&rotation=0&showTitle=false&size=355976&status=done&style=none&taskId=u61319172-2668-4eca-ae06-bf6249a2700&title=&width=407)
可靠消息队列虽然能保证最终结果的相对可靠性，过程也足够简单，但整个过程没有任何隔离性可言，例如扣除库存时，超售，此时只能人工介入来处理。
#### TCC事务
TCC事务是“Try-Confirm-Cancel”三个单词的缩写，是数据库专家Pat Helland在2007年提出来的。TCC事务相对消息队列要复杂，相对于消息队列，可以保证隔离性。

- Try：尝试执行阶段，完成所有业务可执行性的检查（保障一致性），并且预留好全部需要用到的业务资源。
- Confirm：确定执行阶段，不进行任何业务检查，直接使用Try阶段准备的资源来完成业务处理。Confirm阶段可能会重复执行，因此本阶段执行的操作需要具备幂等性。
- Cancel：取消执行阶段，释放Try阶段预留的业务资源。Cancel阶段可能会重复执行，因此本阶段执行的操作也需要具备幂等性。

示例：某电商账户购买某商品：用户账号扣款，库存商品出库，商家账户收款。
1）某账户Bookstore平台购买某商品，发起请求
2）Bookstore服务创建事务，生成事务ID，记录在活动日志中，进行Try阶段

- 账户服务：检查可行性，如果可行，用户冻结XX元，通知下一步进入Confirm阶段。如果不可行，通知下一步进入Cancel阶段。
- 仓库服务：检查业务可行性，如果可性，商品锁定XX个，通知下一步进入Confirm阶段。如果不可行，通知下一步进入Cancel阶段。
- 商家服务：检查业务可行性，因为是收款，不需要锁定。

3）如果第2步，均是可行，执行账户扣款，仓库商品出库，商家收款。**该步保证最大努力交付**，因此该步也是幂等的。
4）如果第2步，有任意一方反馈不可行，或任意一方超时，将活动日志记录为Cancel阶段。用户服务取消操作（释放锁定的金额）、仓库服务取消操作（释放被冻结的商品）、商家服务取消业务操作。**该步保证最大努力交付**。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/8364057/1679138016056-a7d0aa6c-7b7b-42ff-830b-3d8eb45f900e.png#averageHue=%23f9f9f9&clientId=u7348c1cf-b572-4&from=paste&height=586&id=u33f97cd1&originHeight=2016&originWidth=1556&originalType=binary&ratio=1&rotation=0&showTitle=false&size=597191&status=done&style=none&taskId=u41f14001-edfd-4f95-b28d-01d15bbc380&title=&width=452)
TCC事务较为繁琐，且是在业务层实现的，通常通过中间件来实现。TCC其实有点类似2PC，但是TCC是在用户代码层面，而不是基础设施层面，但这也为它实现带来较高的灵活性，可以根据需要锁定资源粒度。业务执行时，也只需要操作预留资源，几乎不会设计锁和资源争用，具备更好的性能优势。但是带来更大的开发成本和业务侵入性，所以常通过中间件来实现。
TCC事务在有些场景并不能满足，例如支付通过银行扣款，银行不会配合做冻结资金操作，那么TCC第一步Try阶段无法实施。此时我们可以考虑另一种柔性事务SAGA事务。
#### SAGA事务
SAGA事务模式的历史比较悠久，还早于分布式事务，源于1987年普林斯顿大学的两位学者发表的一篇论文。文中提出一种提升“长时间事务”运作效率的方法，大致思路是把一个大事务分解为可以交错运行的一系列子事务集合。原本SAGA的目的是避免大事务长时间锁定数据库资源，后来才发展成将一个分布式环境中的大事务分解为一系列本地事务的设计模式。

- 将大事务拆分成若干个小事务，将整个分布式事务分解为n个子事务，命名为T1,T2....Ti...Tn。每个子事务都应该或者能被视为原子行为。如果分布式事务能够正常提交，对数据的影响(最终一致性)应为连续顺序成功提交Ti等价。
- 为每一个子事务设计对应的补偿动作，命名为C1,C2,...Ci....Cn。
- Ti和Ci都具备幂等性。
- Ti和Ci满足交换定律，无论先执行Ti还是先执行Ci，其效果都一样。
- Ci必须能提交成功，不考虑Ci失败或者回滚的情景，如果出现，持续重试直至成功或人工介入。

T1,T2....Ti...Tn均成功提交，那么事务顺利完成，否则，采取以下两种恢复措施：

- 正向恢复：如果Ti事务提交失败，则一直对Ti进行重试，直至成功为止（最大努力交付）。这种恢复方式不需要补偿，适用于事务最终都要成功的场景。
- 反向恢复：如果Ti事务提交失败，则一直执行Ci对Ti进行补偿，直至成功为止（最大努力交付）。反向恢复的执行模式为：T1，T2，…，Ti（失败），Ci（补偿），…，C2，C1。

与TCC相比，SAGA不需要为资源设计冻结状态和撤销冻结的操作，补偿操作往往要比冻结操作容易实现得多。例如从银行扣款操作，如果整体事务失败，把货款转回到银行，这样是可行的。
但SAGA系统本身也有可能会崩溃，所以它必须设计成与数据库类似的日志机制（被称为SAGALog）以保证系统恢复后可以追踪到子事务的执行情况，譬如执行至哪一步或者补偿至哪一步了。另外，尽管补偿操作通常比冻结/撤销容易实现，但保证正向、反向恢复过程严谨地进行也需要花费不少工夫，譬如通过服务编排、可靠事件队列等方式完成，所以，SAGA事务通常也不会直接靠裸编码来实现，一般是在事务中间件的基础上完成。
### 参考
《凤凰架构》《MySql技术内幕》
