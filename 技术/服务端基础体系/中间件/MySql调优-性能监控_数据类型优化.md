## 性能监控
#### show profile
[https://dev.mysql.com/doc/refman/8.0/en/show-profile.html](https://dev.mysql.com/doc/refman/8.0/en/show-profile.html)
```java
SHOWPROFILE[type[,type]...][FORQUERYn][LIMITrow_count[OFFSEToffset]]
type: { ALL|BLOCKIO|CONTEXTSWITCHES|CPU|IPC|MEMORY|PAGEFAULTS|SOURCE|SWAPS }
show profile;
show profile for query id;
```
#### MySQL Performance Schema
[https://dev.mysql.com/doc/refman/8.0/en/performance-schema.html](https://dev.mysql.com/doc/refman/8.0/en/performance-schema.html)
提供了一种在数据库运行时实时检查server的内部执行情况的方法。performance_schema 数据库中的表使用performance_schema存储引擎。该数据库主要关注数据库运行过程中的性能相关的数据，与information_schema不同，information_schema主要关注server运行过程中的元数据信息。
performance_schema通过监视server的事件来实现监视server内部运行情况， “事件”就是server内部活动中所做的任何事情以及对应的时间消耗，利用这些信息来判断server中的相关资源消耗在了哪里？一般来说，事件可以是函数调用、操作系统的等待、SQL语句执行的阶段（如sql语句执行过程中的parsing 或 sorting阶段）或者整个SQL语句与SQL语句集合。事件的采集可以方便的提供server中的相关存储引擎对磁盘文件、表I/O、表锁等资源的同步调用信息。 
## 执行计划
[连老师](http://git.mashibing.com/bjmashibing/InternetArchitect/-/blob/master/13mysql%E8%B0%83%E4%BC%98/mysql%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.md)
[官网](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html)
## Schema与数据类型优化
#### 原则
**应该尽量使用可以正确存储数据的最小数据类型**
更小的数据类型通常更快，因为它们占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周期更少，但是要确保没有低估需要存储的值的范围，如果无法确认哪个数据类型，就选择你认为不会超过范围的最小类型。
**简单数据类型的操作通常需要更少的CPU周期**
例如：
1、整型比字符操作代价更低，因为字符集和校对规则是字符比较比整型比较更复杂，
2、使用mysql自建类型而不是字符串来存储日期和时间
3、用整型存储IP地址
**尽量避免null**
如果查询中包含可为NULL的列，对mysql来说很难优化，因为可为null的列使得索引、索引统计和值比较都更加复杂，坦白来说，通常情况下null的列改为not null带来的性能提升比较小，所有没有必要将所有的表的schema进行修改，但是应该尽量避免设计成可为null的列
#### 实际细则
**整数类型**
尽量使用满足需求的最小数据类型
可以使用的几种整数类型：TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT分别使用8，16，24，32，64位存储空间。
**字符和字符串类型**
varchar根据实际长度保存数据

1. 使用最小的符合需求的长度
2. varchar(n)，n小于等于255使用额外一个字节保存长度，n>255使用额外两个字节保存长度
3. varchar(5)，varchar(255)保存同样的内容，硬盘存储空间相同，但内存空间占用不同，是指定大小
4. varchar在5.6之前变更长度，都会导致锁表
5. 应用场景：存储长度波动较大的数据，如文章；字符串很少更新的场景，每次更新后都会重算并使用额外的存储空间保存长度；适合保存多字节字符，如：汉字，特殊字符。

char固定长度字符串

1. 最大长度：255
2. 会自动删除末尾空格
3. 检索效率、写效率会比varchar高
4. 应用场景：存储长度固定或波动不大，例如md5值，存储短字符串、经常更新的字符串

**BLOB和TEXT**
MySQL 把每个 BLOB 和 TEXT 值当作一个独立的对象处理。
两者都是为了存储很大数据而设计的字符串类型，分别采用二进制和字符方式存储
**datetime和timestamp**
datetime

1. 占用8个字节
2. 与时区无关，数据库底层时区配置
3. 可以保存到毫秒
4. 可保存的时间范围大
5. 不要使用字符串存储日期类型，占用空间大，损失日期类型函数的便捷性

timestamp

1. 占用4个字节
2. 时间范围：1970-01-01到2038-01-19
3. 精确到秒
4. 采用整形存储
5. 依赖数据库设置时区
6. 自动更新timestamp列的值

date

1. 占用3个字节
2. 使用date类型还可以利用日期函数进行日期之间的计算
3. date类型用于保存1000-01-01到9999-12-31之间的日期

**使用枚举代替字符串类型**
有时可以使用枚举类代替常用的字符串类型，mysql存储枚举类型会非常紧凑，会根据列表值的数据压缩到一个或两个字节中，mysql在内部会将每个值在列表中的位置保存为整数，并且在表的.frm文件中保存“数字-字符串”映射关系的查找表
**特殊数据类型**
人们经常使用varchar(15)来存储ip地址，然而，它的本质是32位无符号整数不是字符串，可以使用INET_ATON()和INET_NTOA函数在这两种表示方法之间转换

## 合理使用范式和反范式
#### 范式定义
第一范式：是指数据库的每一列都是不可分割的基本数据项，强调列的原子性。
第二范式：建立在第一范式的基础上，即满足第二范式一定满足第一范式，第二范式要求数据表每一个实例或者行必须被唯一标识。
第三范式：若某一范式是第二范式，且每一个非主属性都不传递依赖于该范式的候选键，则称为第三范式，即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。
> 举例来说：Employee(emp_id,emp_name,emp_age,dept_id,dept_name,dept_info)，当员工表中emp_id能够唯一确定员工员工信息，但是dept_name可由dept_id唯一确定，此时，该表不符合第三范式，此时可以删除除了dept_id之外的其他部门信息，把所有部门信息单独建立一张部门表。

BCNF**：** 在第三范式的基础上，数据库表中如果不存在任何字段对任一候选关键字段的传递函数依赖则符合第三范式。
（1）所有非主属性对每一个码都是完全函数依赖；
（2）所有的主属性对于每一个不包含它的码，也是完全函数依赖；
（3）没有任何属性完全函数依赖于非码的任意一个组合。
> 1. 某公司有若干个仓库；
> 2. 每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；
> 3. 一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。
> 
![image.png](https://cdn.nlark.com/yuque/0/2022/png/8364057/1646821391526-4602372f-b0c4-438f-9f67-616efaf09b7e.png#clientId=ub6abd2ec-f462-4&from=paste&height=148&id=ua30af868&originHeight=296&originWidth=625&originalType=binary&ratio=1&size=24264&status=done&style=none&taskId=u51e1f766-8830-4c50-8ebc-8e30a82df57&width=312.5)
> 修改为
> 仓库（仓库名，管理员）
库存（仓库名，物品名，数量）

#### 范式与反范式
**范式**
优点：范式化的更新通常比反范式要快；当数据较好的范式后，很少或者没有重复数据；范式的数据比较小，可以放在内存中，操作比较快
缺点：通常需要进行关联
**反范式**
优点：所有的数据都在同一张表中，可以避免关联。可以设计有效的索引
缺点：表格内的冗余比较多，删除数据时候会造成有用信息丢失。

在企业中很难能做到严格的范式或者反范式，一般需要混合使用。

## 主键选择
#### 代理主键
与业务无关的，无意义的数字序列
#### 自然主键
事物属性中的自然唯一标识

推荐使用代理主键：它们不与业务耦合，因为更容易维护；一个大多数表，最好是全部表，通用的健

## 字符集选择

1. 纯拉丁字符能标识的内容，没有必要选择latin1之外的其它字符编码，因为这会节省大量的存储空间。
2. 如果不需要多种语言，没有必要一定使用UTF-8或者其他UNICODE字符类型，会造成大量的存储空间浪费。
3. 可以通过不同表字段使用不同的数据类型来较大程度减小数据存储量。
## 存储引擎对比
|  | MyISAM | InnoDB |
| --- | --- | --- |
| 索引类型 | 非聚集索引 | 聚集索引 |
| 支持事务 | 否 | 是 |
| 支持表锁 | 是 | 是 |
| 支持行锁 | 否 | 是 |
| 支持外键 | 否 | 是 |
| 支持全文索引 | 是 | 是（5.6之后） |
| 适合操作类型 | 大量select | 大量insert，delete，update |

## 适当的数据冗余
频繁使用且只能通过Join方式才能得到的独立小字段，可以通过空间换时间的方式来优化。不过，冗余的同时需要确保数据的一致性不会遭到破坏。
## 适当拆分
当我们的表中存在类似于 TEXT 或者是很大的 VARCHAR类型的大字段的时候，如果我们大部分访问这张表的时候都不需要这个字段，我们就该义无反顾的将其拆分到另外的独立表中，以减少常用数据所占用的存储空间。这样做的一个明显好处就是每个数据块中可以存储的数据条数可以大大增加，既减少物理 IO 次数，也能大大提高内存中的缓存命中率。
