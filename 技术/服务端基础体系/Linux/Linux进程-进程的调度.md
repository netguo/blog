可以先设想一个问题，对于进程的调度，操作系统需要满足什么样的需求呢？
* 对于time-sharing(分片)的进程，调度器必须是公平的
* 快速的进程响应时间
* 系统的throughput要高
* 功耗要小  
  
### 调度策略和优先级
先了解几个概念，这几个概念配合使用，构成了进程的调度：
* 从调度角度，进程分为两类：实时进程，普通进程。
* 在task_struct结构时，我们有了解过有一个调度策略字段
  `unsigned int policy` 。
* 优先级，分为动态优先级和静态优先级
  ```  
  int prio, static_prio, normal_prio;
  unsigned int rt_priority;
  ```
##### 优先级
优先级其实就是一个数值，对于实时进程，优先级的范围是 0～99；对于普通进程，优先级的范围是 100～139。数值越小，优先级越高。从这里可以看出，所有的实时进程都比普通进程优先级要高。
所谓静态优先级就是task固有的优先级，不会随着进程的行为而改变。
##### 调度策略
调度策略主要有以下几个：
```
#define SCHED_NORMAL    0
#define SCHED_FIFO    1
#define SCHED_RR    2
#define SCHED_BATCH    3
#define SCHED_IDLE    5
#define SCHED_DEADLINE    6
```
对于普通进程和实时进程所使用的调度策略是有所区别的。  
实时进程：
* SCHED_FIFO：优先保证优先级高的进程先执行，相同优先级的进程先进先出
* SCHED_RR：优先保证优先级高的进程先执行，相同优先级的进程，按照时间片轮训执行
* SCHED_DEADLINE：选择其 deadline 距离当前时间点最近的那个任务
  
普通进程，分为以下三类：  
* SCHED_NORMAL：正常的普通进程，2.6以后采用CFS调度
* SCHED_BATCH：后台进程，几乎不需要和前端进行交互，可以降低它的优先级
* SCHED_IDLE：特别空闲的时候才跑的进程。

### CFS（Completely Fair Scheduling）完全公平调度算法
#### CFS原理
CFS是Linux内核2.6引入进来的，2.6之前cpu调度通过一系列运行指标确定进程的优先级，然后根据进程的优先级确定调度哪个进程，而CFS则转换了一种思路，它不计算优先级，而是通过计算进程消耗的CPU时间（标准化以后的虚拟CPU时间）来确定谁来调度。从而到达所谓的公平性。
* 绝对公平性：  
cfs定义了一种新的模型，其基本思路很简单，他把CPU当做一种资源，并记录下每一个进程对该资源使用的情况，在调度时，调度器总是选择消耗资源最少的进程来运行。这就是所谓的“完全公平”。但这种绝对的公平有时也是一种不公平，因为有些进程的工作比其他进程更重要，我们希望能按照权重来分配CPU资源。
* 相对公平性：
为了区别不同优先级的进程，就是会根据各个进程的权重分配运行时间(权重怎么来的后面再说)。进程的运行时间计算公式为: 分配给进程的运行时间 = 调度周期 * 进程权重 / 所有进程权重之和 (公式1)

#### Linux的实现
Linux引入虚拟运行时间vruntime，具体计算如下：  

![vruntime](../../picture/Linux/vruntime.svg)

cpu.share = 权重默认权重1024，cpu.share(default)=进程权重，runtime就是线程目前运行过的实际总合。

从公式中可以看出，实际上也比较好理解，vruntime = 运行时间总和 * 1024 / 进程权重 。 (公式2)  

实际上vruntime就是根据权重将实际运行时间标准化，标准化之后，各个进程对资源的消耗情况就可以直接通过比较vruntime来知道，比如某个进程的vruntime比较小，我们就可以知道这个进程消耗CPU资源比较少，反之消耗CPU资源就比较多。
  
> 有了vruntime的概念后，调度算法就非常简单了，谁的vruntime值较小就说明它以前占用cpu的时间较短，受到了“不公平”对待，因此下一个运行进程就是它。这样既能公平选择进程，又能保证高优先级进程获得较多的运行时间。这就是CFS的主要思想了。   
> 
> 或者可以这么理解：CFS的思想就是让每个调度实体（没组调度的情形下就是进程，以后就说进程了)的vruntime互相追赶，而每个调度实体的vruntime增加速度不同，权重越大的增加的越慢，这样就能获得更多的cpu执行时间。  
> 
> 具体实现上，Linux采用了一颗红黑树（对于多核调度，实际上每一个核有一个自己的红黑树），记录下每一个进程的vruntime，需要调度时，从红黑树中选取一个vruntime最小的进程出来运行。

#### 新创建的线程和休眠后的线程
新进程

>假如新进程的vruntime初值为0的话，比老进程的值小很多，那么它在相当长的时间内都会保持抢占CPU的优势，老进程就要饿死了，这显然是不公平的。CFS是这样做的：每个CPU的运行队列cfs_rq都维护一个min_vruntime字段，记录该运行队列中所有进程的vruntime最小值，新进程的初始vruntime值就以它所在运行队列的min_vruntime为基础来设置，与老进程保持在合理的差距范围内。

> * 子进程在创建时，vruntime初值首先被设置为min_vruntime；
> * 如果sched_features中设置了START_DEBIT位（延迟），vruntime会在min_vruntime的基础上再增大一些。
> * 设置完子进程的vruntime之后，检查sched_child_runs_first参数，如果为1的话，就比较父进程和子进程的vruntime，若是父进程的vruntime更小，就对换父、子进程的vruntime，这样就保证了子进程会在父进程之前运行。

休眠进程 

>如果休眠进程的 vruntime 保持不变，而其他运行进程的 vruntime 一直在推进，那么等到休眠进程终于唤醒的时候，它的vruntime比别人小很多，会使它获得长时间抢占CPU的优势，其他进程就要饿死了。这显然是另一种形式的不公平。CFS是这样做的：在休眠进程被唤醒时重新设置vruntime值，以min_vruntime值为基础，给予一定的补偿，但不能补偿太多。（min_vruntime-xxx）

>由于休眠进程在唤醒时会获得vruntime的补偿，所以它在醒来的时候有能力抢占CPU是大概率事件，这也是CFS调度算法的本意，即保证交互式进程的响应速度，因为交互式进程等待用户输入会频繁休眠。

> 也有一些禁止唤醒抢占等特性可以配置。



### 参考
[Linux的公平调度（CFS）原理](https://www.jianshu.com/p/673c9e4817a8)