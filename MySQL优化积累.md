本文大多数是从书中或者blog看到的，平时应用是，作为依据、参考点

#### 索引
提到MySQL优化，可能首先想到的是索引
在MySQL中按照索引的实现，的类型有Hash索引，BTree索引    

###### 索引的实现
_Hash索引_
通过hash实现，hash通过O(1)的时间复杂度就可以实现，但是实用度有限。
*  对于Hash来讲，只适合于=，in，<=>，is not null操作，不适合范围值查询
*  对于相同值较多的数据，hash查询出之后还需要进行查库操作，效率有限
*  Hash索引不能利用部分索引键查询。对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。
*  Hash索引不适合排序操作，也就是ORDER BY操作，因为hash是无序的

_BTree索引_
利用B+树，或者B-树。复杂度O(logm n)，大多数引擎都默认为BTree索引
  
###### 索引的类型  

1. 普通索引  
`CREATE INDEX indexName ON mytable(username(length)); `如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定length。

2. 唯一索引  
索引列的值必须唯一，但允许有空值。如果是组合索引，则列值得组合必须唯一。   
`ALTER mytable ADD UNIQUE [indexName] ON (username(length)) `  

3. 主键索引
它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引。`PRIMARY KEY(ID)`  

4. 组合索引
最左前缀




###### 注意事项

1. 建立索引的列，一般是Where中使用的列，或者连接子句join on中条件列。
2. 使用短索引，如果一列前20的字符很少有重复，对前20个字符建立索引即可
3. 不要过度使用索引，额外的磁盘空间,并降低写操作的性能
4. 列的比较运算中（只是比较），索引可用于<、< = 、= 、> =、>和BETWEEN、IN运算，在模式具有一个直接量前缀时(例如："abc%"),索引也用于LIKE 运算
5. 索引不会包含NULL值，只要列中包含有NULL值，都不会包含在索引中，复合索引中只要有一列含有NULL，那么这一列对于复合索引是无效的。设计时可以设置NOT NULL
6. 不使用NOT IN，<> 操作。根据4可见，这两个比较操作不支持索引
7. 索引字段进行计算时，如count/2，Date(time)会导致索引失效

#### SQL优化  

###### 优化目标：
1.减少IO次数。IO是最容易出瓶颈的地方。在SQL编写中需要格外注意。  
2.降低CPU计算。order by, group by,distinct等操作是消耗CPU较多的操作。

###### 优化经验
大多是通过学习得来的，平时用的时候有做参考

_尽量少用join_  
MySQL的优化器效率高，但是有限。对于复杂的多表join一方面其优化器受限，其次Mysql这方面工作有限。尽量避免复杂的多表join.

_尽量少排序_
排序会消耗较多的CPU资源，减少排序可以在缓存命中率高等IO能力足够的场景下会较大影响SQL响应时间。

_尽量避免select * _
养成用什么，取什么的好习惯

_尽量用join代替子查询_
虽然 Join 性能并不佳，但是和 MySQL 的子查询比起来还是有非常大的性能优势。

_尽量少用or_

当 where 子句中存在多个条件以“或”并存的时候，MySQL 的优化器并没有很好的解决其执行计划优化问题，再加造成了其性能比较低下，很多时候使用 union all 或者是union(必要的时候)的方式来代替“or”会得到更好的效果。

_尽量用union all代替union_
union 和 union all 的差异主要是前者需要将多个结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的CPU运算，加大资源消耗及延迟。所以当我们可以确认不可能出现重复结果集或者不在乎重复结果集的时候，尽量使用 union all 而不是 union。

_尽早过滤_
这一优化策略其实最常见于索引的优化设计中(将过滤性更好的字段放得更靠前)    

_尽可能的使用NOT NULL
NULL在MySQL中也会有存储空间，Varchar可以使用EMPTY，INT可以使用0

_尽可能对每一条运行在数据库中的SQL进行explain_  
这个很重要啊，在应用开发，还是优化过程中，对每一个SQL进行explain是很重要的啊

_从全局出发优化，而不是片面调整_
SQL优化不能是单独针对某一个进行，而应充分考虑系统中所有的 SQL，尤其是在通过调整索引优化 SQL 的执行计划的时候，千万不能顾此失彼，因小失大。

