
### 总结一次解决问题过程   
     
#### 前提描述：  
  
* 需求描述：产品提出一种将生成的页面报告生成PDF导出给客户的需求。  
* 方案描述：在最初定方案时有两种想法，一种是在node端做，并直接导出给客户。另一种在java服务端做，生成后导出后传到网上云盘，url传递给前端。  
* 方案选择：由于产品进度，加上我们前端人手不足，只能选择在java服务端做。    

#### 问题描述  
  
选型在java服务端后，同事网上找了通用的开源项目：flying-saucer，写了一个样例，然后做其它事情去了。然后就开始我一天解决问题之路。

------   

#### 解决问题过程      

##### 一、方案改型   
   
* 修改a：在项目中，通过html写了一个模板，打算在html读入后，自己构造变量解释函数，塞入数据。  
  * 自己构造变量进入本身是一个复杂的工作，可以采用velocity模板来解决。  

  
  
* 修改b ：将导出报告放在source目录下，source本身是放一些xml，properties配置文件，代码格局不合理。  
  * 加载本地文件，spring本身提供了CLASSPATH，FILE方式，可以通过加载file方式，在webapp下定义一个输出路径，并加载。   

#### 问题出现，解决历程   
  
##### 问题：当通过velocity解析到HTML文件，并传递给flying-saucer代码时，并没有报任何错误。  

##### 历程一：分析同事代码，网上追踪正确性  
先看同事给的代码，如下代码片段，思路也很清晰，从html文件中读入并解析成dom，利用  flying-saucer中方法输出为pdf。    

_排错：_  

* 网上搜索flying-saucer导出PDF的使用方式，代码基本相似。  
  
  * 网上搜索到示例代码，和这个代码使用类似。代码还是这样，但是在解析dom时，Documment总是为null。    
  * 有查到flying-saucer对于HTML文档要求格式必须严格正确，必有DOCTYPE和xml的声明。然并卵，Document还是解析为null。  
  
* 官网查找示例文档  
  *  代码托管在Googlecode上，查看示例代码发现有一个renderer.setDocumentFromString()的方法，这样可以直接将velocity解析出的HTML的String格式传入。
  *  结果有报错（报错并不可怕，怕的是不抱任何错误），解析为Document报空指针，没有任何提示。    

* 仔细检查了一下HTML格式，确保了正确性，然后还是报同样的错误，追踪源码也没有看到具体的错误原因。  

_结论：_  flying-saucer做的并不够好，先尝试寻找其它开源项目。


```  
    public void renderPDF(String url, FileOutputStream pdfos) throws IOException, DocumentException {
        /*
         * standard approach ITextRenderer renderer = new ITextRenderer(); renderer.setDocument(url); renderer.layout();
         * renderer.createPDF(os);
         */

        ITextRenderer renderer = new ITextRenderer();
        ResourceLoaderUserAgent callback = new ResourceLoaderUserAgent(renderer.getOutputDevice());
        callback.setSharedContext(renderer.getSharedContext());
        renderer.getSharedContext().setUserAgentCallback(callback);

        Document doc = XMLResource.load(new InputSource(url)).getDocument();

        renderer.setDocument(doc, url);
        // 解决中文支持问题
        ITextFontResolver fontResolver = renderer.getFontResolver();
        fontResolver.addFont(fontPath, BaseFont.IDENTITY_H, BaseFont.NOT_EMBEDDED);

        renderer.layout();
        renderer.createPDF(pdfos);

        pdfos.close();
    }      
```      

##### 历程二：尝试换一个新的开源项目来输入PDF  

_搜索:_ 搜索方式很重要！！！！    

通常我自己比较多的搜索方式有两个目标：stackoverflow和github    

* 可以用google的搜索技巧，site:http://stackoverflow.com/  关键字  
* 在github或stackoverflow上直接搜索关键字  

_答案：_    

* 大多数用itext的本身输入html的方法，如下示例  
  * 经过验证对于css支持并不够好。  

```  
        com.itextpdf.text.Document document = new com.itextpdf.text.Document();
        PdfWriter.getInstance(document, pdfos);
        document.open();
        HTMLWorker htmlWorker = new HTMLWorker(document);
        htmlWorker.parse(new StringReader(htmlString));
        document.close();
        pdfos.close();    
```       
        
_再次搜索：_  

* 考虑到上述搜索的结果，看看国内对于这个问题是怎么解决的    
  * 结果很失望，还是用flying-saucer比较多，说是可以很好解决css，样式，支持到2.1  


##### 重新回归原方案flying-saucer，通过实验来定位错误
 
_实验 :_     

* 判断是文档问题，还是velocity解析问题  
	* 将velocity解析出的HTML输出到文件中，读入结果解析到document还是null  
* 怀疑是方法冲突造成的  
  * 将这次新引入的jar去掉，重新编译，重新操作还是失败  
* html本身文档问题  
	* 创建一个最基本的html文档，只包含head，body和一个test字符，结果导成功。  
	* 因为HTML文件本身并么有问题（已经检查过n次），怀疑对于某些标签不支持。  
	* 可以定位不支持标签，一个混乱复杂的过程啊！！！一个个的标签尝试。
	* 结果发现，当元素中含有id是就会失败，坑爹啊！！！官网示例是支持的啊！！！  

_结果:_ 到此问题就解决了，flying-saucer在我们项目中，对dom元素的id不支持。  

#### 结论与总结    

_一个小小id的bug，历经一天才解决，可谓是历经挫折，不过收获还是挺大的，也发现自己在解决问题时的一些缺点:_  

* 在选择换方案时，应该先从网上查找资料获取到有无必要去换。  
* 在寻找bug时，应该先确认有哪几种可能性，优先级从高到底排个顺序，再去定位。     
      



 

