#杂谈设计模式

### 设计模式是什么
1. 模式的来源
	- 与很多软件工程技术一样，模式起源于建筑领域，毕竟与只有几十年历史的软件工程相比，已经拥有几千年沉淀的建筑工程有太多值得学习和借鉴的地方。
	- Christopher Alexander博士及其研究团队用了约20年的时间，对住宅和周边环境进行了大量的调查研究和资料收集工作，发现人们对舒适住宅和城市环境存在一些共同的认同规律，把这些认同规律归纳为253个模式，对每一个模式(Pattern)，都从Context（前提条件）、Theme或Problem（目标问题）、 Solution（解决方案）三个方面进行了描述，并给出了从用户需求分析到建筑环境结构设计直至经典实例的过程模型。
	- 后来他给出了关于模式的定义：每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，通过这种方式，我们可以无数次地重用那些已有的成功的解决方案，无须再重复相同的工作。
	- GoF在1994年将模式的概念引入软件工程领域，这标志着软件模式的诞生。软件模式的基础结构主要由四部分构成，包括问题描述、前提条件、解法和效果。

2. 设计模式是什么
	* 定义：是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。
	* 狭义上定义：GoF在《设计模式：可复用面向对象软件的基础》一书中所介绍的23种经典设计模式，不过设计模式并不仅仅只有这23种，随着软件开发技术的发展，越来越多的新模式不断诞生并得以应用。

3. 设计模式有什么用
	* 可以避免很多重复性的设计工作。源于众多专家的经验和智慧，是从许多优秀的软件系统中总结出的成功的、能够实现可维护性复用的设计方案。
	* 设计模式提供了一套通用的设计词汇和一种通用的形式方便开发人员之间的沟通和交流，使得方案更加通俗易懂。
	* 减少代码维护的成本。大部分设计模式都兼顾了系统的可重用性和可扩展性。方便以后的灵活扩充，拓展。
	* 有助于初学者更加深入地理解面向对象思想，也能够更好地阅读和理解一些Java源代码。

4. 设计模式的荼毒
	* 滥用
	[hello,world的设计模式的滥用](http://m58elw.blog.163.com/blog/static/2402030752014101931554302/)  
	
	* 圣经
	设计模式给出的只是一些过去经验，一些比较好的设计集锦，而不是设计理论
	例如：GoF，Design Patterns - Element of Resuable Object-Oriented software design在国内翻译为《设计模式：可复用面向对象软件的基础》，基础，基础，基础！瞬间高大上   
	
	* 空谈
	空谈设计模式而不知怎么去应用

---
### 设计模式的六大原则
* 单一职责原则
* 里氏替换原则
* 依赖倒置原则
* 接口隔离原则
* 迪米特法则
* 开闭原则

---  
### 23种设计模式
[设计模式](design_pattern.html)

---
### Java中的设计模式
单例模式    

```
   public static CustomFormNodeParse getInstance() {
        return CustomFormNodeParseHold.INSTANCE;
    }

    private static class CustomFormNodeParseHold {

        private static final CustomFormNodeParse INSTANCE = new CustomFormNodeParse();
    }  
```

抽象工厂模式

``` 
public interface Connection  extends Wrapper, AutoCloseable {
    Statement createStatement() throws SQLException;
}    

public class DruidPooledConnection extends PoolableWrapper implements javax.sql.PooledConnection, Connection {
    @Override
    public Statement createStatement() throws SQLException {
        checkState();

        Statement stmt = null;
        try {
            stmt = conn.createStatement();
        } catch (SQLException ex) {
            handleException(ex);
        }

        holder.getDataSource().initStatement(this, stmt);

        DruidPooledStatement poolableStatement = new DruidPooledStatement(this, stmt);
        holder.addTrace(poolableStatement);

        return poolableStatement;
    }
}
```  
提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。

---  

装饰模式  

```   
 使用方式：
 BufferedInputStream bufferedInputStream =new BufferedInputStream(new FileInputStream(srcFile));


public abstract class InputStream implements Closeable {

    private static final int MAX_SKIP_BUFFER_SIZE = 2048;
    public abstract int read() throws IOException;
    public int read(byte b[]) throws IOException {
        return read(b, 0, b.length);
    }
    public int read(byte b[], int off, int len) throws IOException {
        ..
    }

    .....
}   
public class FileInputStream extends InputStream{}

public class FilterInputStream extends InputStream {

    protected volatile InputStream in;

    protected FilterInputStream(InputStream in) {
        this.in = in;
    }

    ....
}

public class BufferedInputStream extends FilterInputStream {

    private static int defaultBufferSize = 8192;

    protected volatile byte buf[];
    ......

    public BufferedInputStream(InputStream in) {
        this(in, defaultBufferSize);
    }

    public BufferedInputStream(InputStream in, int size) {
        super(in);
        if (size <= 0) {
            throw new IllegalArgumentException("Buffer size <= 0");
        }
        buf = new byte[size];
    }
    ......
}
```

装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例
  
  ---

享元模式  

```
java.lang.Integer.valueOf(int i)

private static class IntegerCache {
    static final int low = -128;
    static final int high;
    static final Integer cache[];

    static {
        // high value may be configured by property
        int h = 127;
        String integerCacheHighPropValue =
            sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
        if (integerCacheHighPropValue != null) {
            int i = parseInt(integerCacheHighPropValue);
            i = Math.max(i, 127);
            // Maximum array size is Integer.MAX_VALUE
            h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
        }
        high = h;

        cache = new Integer[(high - low) + 1];
        int j = low;
        for(int k = 0; k < cache.length; k++)
            cache[k] = new Integer(j++);
    }

    private IntegerCache() {}
}

```  

享元模式(Flyweight Pattern)：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。

---  

策略模式

```  
public interface Comparator<T> {
    int compare(T o1, T o2);
}
```   
策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。

